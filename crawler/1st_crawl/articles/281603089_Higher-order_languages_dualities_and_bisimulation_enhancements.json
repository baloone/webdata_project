{"id":"281603089_Higher-order_languages_dualities_and_bisimulation_enhancements","abstract":"The behaviours of concurrent processes can be expressed using process calculi, which are simple formal languages that let us establish precise mathematical results on the behaviours and interactions between processes. A very simple example is CCS, another one is the pi-calculus, which is more expressive thanks to a name-passing mechanism. The pi-calculus supports the addition of type systems (to refine the analysis to more subtle environments) and the encoding of the lambda-calculus (which represents sequential computations).Some of these calculi, like CCS or variants of the pi-calculus such as fusion calculi, enjoy a property of symmetry. First, we use this symmetry as a tool to prove that two encodings of the lambda-calculus in the pi-calculus are in fact equivalent.This proof using a type system and a form of symmetry, we wonder if other existing symmetric calculi can support the addition of type systems. We answer negatively to this question with an impossibility theorem.Investigating this theorem leads us to a fundamental constraint of these calculi that forbids types: they induce an equivalence relation on names. Relaxing this constraint to make it a preorder relation yields another calculus that recovers important notions of the pi-calculus, that fusion calculi do not satisfy: the notions of types and of privacy of names. The first part of this thesis focuses on the study of this calculus, a pi-calculus with preorders on names.The second part of this thesis focuses on bisimulation, a proof method for equivalence of agents in higher-order languages, like the pi- or the lambda-calculi. An enhancement of this method is the powerful theory of bisimulations up to, which unfortunately only applies for first-order systems, like automata or CCS.We then proceed to describe higher-order languages as first-order systems. This way, we inherit the general theory of up-to techniques for these languages, by proving correct the translations and up-to techniques that are specific to each language. We give details on the approach, to provide the necessary tools for future applications of this method to other higher-order languages.","authors":["Jean-Marie Madiot"],"meta":["March 2015"],"references":["318636287_On_asynchrony_in_name-passing_calculi","266557456_A_Concurrent_Pattern_Calculus","239060192_Locality_in_the-calculus_and_applications_to_distributed_objects","231932704_Explicit_Substitutions","228948999_Implicative_Logic_based_encoding_of_the_l-calculus_into_the_p-calculus","221530765_A_General_Name_Binding_Mechanism","220997280_Small_bisimulations_for_reasoning_about_higher-order_imperative_programs","220700934_Reversible_Communicating_Systems","220370562_From_Applicative_to_Environmental_Bisimulation","3811856_Towards_a_theory_of_bisimulation_for_local_names","319541034_Polymorphic_pi-calculus_theory_and_implementation","312653734_Barbed_bisimulation_In_Proceedings_of_International_Colloquium_on_Automata_Languages_and_Programming_ICALP","312589793_Techniques_modulo_pour_les_bisimulations","311490305_Bisimulation_up-to_techniques_for_psi-calculi","303968960_A_Bisimulation_for_Type_Abstraction_and_Recursion","286487882_Enhanced_coalgebraic_bisimulation","271353895_A_Behavioural_Theory_for_a_p-calculus_with_Preorders","265371850_Enhancements_of_the_bisimulation_proof_method","262257218_The_x-Calculus","262242935_What_is_a_Good_Encoding_of_Guarded_Choice","262162533_On_bisimulations_of_the_asynchronous_pgr-calculus","261162212_Name-Passing_Calculi_From_Fusions_to_Preorders_and_Types","257604838_First-Order_Reasoning_for_Higher-Order_Concurrency","244516316_Themes_in_Final_Semantics","242519195_Domains_and_lambda_calculi","242435377_The_Lambda_Calculus_Its_Syntax_and_Semantics","240813346_Relational_Reasoning_about_Functions_and_Nondeterminism","239016721_Explicit_Fusions_Theory_and_Implementation","227139184_An_efficiency_preorder_for_processes","225173635_Explicit_Fusions","224001269_Communication_and_Concurrency","223820852_On_the_Expressiveness_of_Internal_Mobility_in_Name-Passing_Calculi","223630020_A_bisimulation_for_dynamic_sealing","222659550_Resource_Access_Control_in_Systems_of_Mobile_Agents","222449825_On_reduction-based_process_semantics","222120495_Call-by-name_call-by-value_and_the_l-calculus","221443281_Psi-calculi_Mobile_Processes_Nominal_Data_and_Logic","221443111_The_Fusion_Calculus_Expressiveness_and_Symmetry_in_Mobile_Processes","220898221_Structural_Operational_Semantics_and_Bisimulation_as_a_Congruence_Extended_Abstract","220700791_The_Tau-Laws_of_Fusion","220690132_The_Pi-Calculus_-_a_theory_of_mobile_processes","220673109_A_Bisimulation_Method_for_Cryptographic_Protocols","220430673_Behavioral_theory_for_Mobile_Ambients","220404737_Environmental_Bisimulations_for_Higher-Order_Languages","220173607_Typing_and_Subtyping_for_Mobile_Processes","220153974_Testing_Equivalences_for_Processes","220151130_Towards_an_algebraic_theory_of_typed_mobile_processes","213881728_Mobile_Values_New_Names_and_Secure_Communication","29618517_Asynchrony_and_the_Pi-calculus","3556210_Typing_and_subtyping_for_mobile_processes","2816767_On_the_Bisimulation_Proof_Method","2811818_Pi-Calculus_Internal_Mobility_And_Agent-Passing_Calculi","2684949_An_Object_Calculus_for_Asynchronous_Communication","2517159_The_Polyadic_p-Calculus_a_Tutorial","2513082_Linearity_and_the_Pi-Calculus"]}