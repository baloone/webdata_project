{"id":"308607126_From_program_verification_to_program_synthesis","abstract":"This paper describes a novel technique for the synthesis of imperative programs. Automated program synthesis has the potential to make programming and the design of systems easier by allowing programs to be specified at a higher-level than executable code. In our approach, which we call proof-theoretic synthesis, the user provides an input-output functional specification, a description of the atomic operations in the programming language, and a specification of the synthesized program's looping structure, allowed stack space, and bound on usage of certain operations. Our technique synthesizes a program, if there exists one, that meets the input-output specification and uses only the given resources.\nThe insight behind our approach is to interpret program synthesis as generalized program verification, which allows us to bring verification tools and techniques to program synthesis. Our synthesis algorithm works by creating a program with unknown statements, guards, inductive invariants, and ranking functions. It then generates constraints that relate the unknowns and enforces three kinds of requirements: partial correctness, loop termination, and well-formedness conditions on program guards. We formalize the requirements that program verification tools must meet to solve these constraint and use tools from prior work as our synthesizers.\nWe demonstrate the feasibility of the proposed approach by synthesizing programs in three different domains: arithmetic, sorting, and dynamic programming. Using verification tools that we previously built in the VS3 project we are able to synthesize programs for complicated arithmetic algorithms including Strassen's matrix multiplication and Bresenham's line drawing; several sorting algorithms; and several dynamic programming algorithms. For these programs, the median time for synthesis is 14 seconds, and the ratio of synthesis to verification time ranges between 1x to 92x (with an median of 7x), illustrating the potential of the approach.","authors":["Saurabh Srivastava","Sumit Gulwani","Jeffrey S. Foster"],"meta":["January 2010ACM SIGPLAN Notices 45(1):313","DOI:10.1145/1707801.1706337"],"references":["234827421_On_the_synthesis_of_a_reactive_module","221495890_Synthesis_of_Programs_in_Computational_Logic","221403057_Repair_of_Boolean_Programs_with_an_Application_to_C","220997415_Back_to_the_future_Revisiting_precise_program_verification_using_SMT_solvers","220884474_Optimizations_for_LTL_Synthesis","220852069_Inferring_Synchronization_under_Limited_Observability","220752241_Program_Verification_using_Templates_over_Predicate_Abstraction","220424298_Toward_Automatic_Program_Synthesis","279352964_The_Science_of_Programming","225828317_A_constructive_approach_to_the_problem_of_program_correctness","221591684_Flow_Graph_Reducibility","221551130_Constraint-Based_Invariant_Inference_over_Predicate_Abstraction","221496032_Schema-Guided_Synthesis_of_Imperative_Programs_by_Constraint_Solving","221475839_Heuristics_for_program_synthesis_using_loop_invariants","221402999_Program_Repair_as_a_Game","221402938_VS3_SMT_solvers_for_program_verification","220751823_Sketching_concurrent_data_structures","220160808_An_Abstract_Formalization_of_Correct_Schemas_for_Program_Synthesis","200031684_Guarded_Commands_Nondeterminacy_and_Formal_Derivation_of_Programs","47861725_Termination_Proofs_for_Systems_Code","44402906_A_discipline_of_programming_Edsger_W_Dijkstra","31610558_Systematic_programming_an_introduction_N_Wirth","2876792_Abstractions_from_Proofs"]}