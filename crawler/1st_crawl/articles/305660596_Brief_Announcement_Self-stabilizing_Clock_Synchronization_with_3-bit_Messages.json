{"id":"305660596_Brief_Announcement_Self-stabilizing_Clock_Synchronization_with_3-bit_Messages","abstract":"This paper is motivated by the aspiration to identify the weakest computational models that allow for efficient, robust distributed computation. We focus on one of the most fundamental building-blocks in distributed computing, namely, Broadcast. In this problem, a unique source agent $s$ needs to disseminate a bit $b$ to the rest of the population. To account for unpredictability issues that may result from uncoordinated executions, we consider a self-stabilizing setting, in which a correct configuration must be reached eventually, despite processors starting the execution with arbitrary initial states (that do not violate the requirement for the existence of a unique source). Similarly to many works on broadcast, we consider a synchronous communication model on a complete anonymous network, in which in each round, each agent can extract information from two other agents, chosen uniformly at random. Our focus is on identifying the smallest message size that is required in order to achieve fast self-stabilizing broadcast. We first observe that with an extra bit added to the message-size and a small additive penalty to the running time, the self-stabilizing broadcast problem can be reduced to a self-stabilizing clock-synchronization problem, where agents aim to synchronize their clocks modulo some integer T. Our main technical contribution lies in solving the latter problem in poly-logarithmic time using only 3 bits per interaction. This allows for a self-stabilizing broadcast protocol that uses only 4 bits per interaction and converges in O log n time.","authors":["Lucas Boczkowski","Amos Korman","Emanuele Natale"],"meta":["July 2016","DOI:10.1145/2933057.2933075","Conference: the 2016 ACM Symposium"],"references":["307630468_Stable_leader_election_in_population_protocols_requires_linear_time","301846203_Self-Stabilizing_Clock_Synchronization_with_3-bit_messages","272752430_Polylogarithmic-Time_Leader_Election_in_Population_Protocols_Using_Polylogarithmic_States","226549261_Computation_in_Networks_of_Passively_Mobile_Finite-State_Sensors","3880868_Randomized_rumor_spreading","272423141_Stable_Leader_Election_in_Population_Protocols_Requires_Linear_Time","267987625_Stabilizing_Consensus_With_the_Power_of_Two_Choices","239552157_Self_stabilizing_systems_in_spite_of_distributed_control","221662193_Stone_Age_Distributed_Computing","221344022_Computation_in_networks_of_passively_mobile_finite-state_sensors","221343918_Epidemic_Algorithms_for_Replicated_Database_Maintenance","220975005_Stabilizing_Consensus_in_Mobile_Networks","220623522_Epidemic_Algorithms_for_Replicated_Database_Maintenance","220423523_Dijkstra_EW_Self-stabilizing_Systems_in_Spite_of_Distributed_Control_ACM_Commun_1711_643-644"]}