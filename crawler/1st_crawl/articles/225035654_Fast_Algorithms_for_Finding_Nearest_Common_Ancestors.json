{"id":"225035654_Fast_Algorithms_for_Finding_Nearest_Common_Ancestors","abstract":"The authors consider the following problem: Given a collection of rooted trees, answer on-line queries of the form, 'What is the nearest common ancestor of vertices x and y? ' They show that any pointer machine that solves this problem requires OMEGA (log log n) time per query in the worst case, where n is the total number of vertices in the trees. On the other hand, they present an algorithm for a random access machine with uniform cost measure (and a bound of O(log n) on the number of bits per word) that requires O(1) time per query and O(n) preprocessing time, assuming that the collection of trees is static. For a version of the problem in which the trees can change between queries, they obtain an almost-linear-time (and linear-space) algorithm.","authors":["Dov Harel","Robert Endre Tarjan"],"meta":["May 1984SIAM Journal on Computing 13:338-355","DOI:10.1137/0213024"],"references":["220430653_Worst-case_Analysis_of_Set_Union_Algorithms","265366148_On_Finding_Lowest_Common_Ancestors_in_Trees","222870890_A_linear-time_algorithm_for_a_special_case_of_disjoint_set_union","222463929_A_Data_Structure_for_Dynamic_Trees","222449893_A_class_of_algorithms_which_require_nonlinear_time_to_maintain_disjoint_sets","220688555_The_Design_and_Analysis_Computer_Algorithms","220688483_The_Art_of_Computer_Programming_Volume_I_Fundamental_Algorithms","220617858_Lecture_Notes_in_Computer_Science","220617569_An_Efficient_Method_for_Storing_Ancestor_Information_in_Trees","220430354_Applications_of_Path_Compression_on_Balanced_Trees","220268321_Two_Applications_of_a_Probabilistic_Search_Technique_Sorting_x_y_and_Building_Balanced_Search_Trees","213886844_Efficiency_of_a_Good_But_Not_Linear_Set_Union_Algorithm","4354635_A_linear_time_algorithm_for_the_lowest_common_ancestors_problem"]}