{"id":"280970262_Efficient_Counting_with_Optimal_Resilience","abstract":"In the synchronous c-counting problem, we are given a synchronous system of n nodes, where up to f of the nodes may be Byzantine, that is, have arbitrary faulty behaviour. The task is to have all of the correct nodes count modulo c in unison in a self-stabilising manner: regardless of the initial state of the system and the faulty nodesâ€™ behavior, eventually rounds are consistently labelled by a counter modulo c at all correct nodes.\nWe provide a deterministic solution with resilience \\(f<n/3\\) that stabilises in O(f) rounds and every correct node broadcasts \\(O(\\log ^2 f)\\) bits per round. We build and improve on a recent result offering stabilisation time O(f) and communication complexity \\(O(\\log ^2 f /\\log \\log f)\\) but with sub-optimal resilience \\(f = n^{1-o(1)}\\) (PODC 2015). Our new algorithm has optimal resilience, asymptotically optimal stabilisation time, and low communication complexity. Finally, we modify the algorithm to guarantee that after stabilisation very little communication occurs. In particular, for optimal resilience and polynomial counter size \\(c=n^{O(1)}\\), the algorithm broadcasts only O(1) bits per node every \\(\\Theta (n)\\) rounds without affecting the other properties of the algorithm; communication-wise this is asymptotically optimal.","authors":["Christoph Lenzen","Joel Rybicki"],"meta":["August 2015","DOI:10.1007/978-3-662-48653-5_2","SourcearXiv","Conference: International Symposium on Distributed Computing"],"references":["236248234_Synchronous_Counting_and_Computational_Algorithm_Design","221540384_Self-stabilizing_Byzantine_Digital_Clock_Synchronization","221343677_Fast_Self-Stabilizing_Byzantine_Tolerant_Digital_Clock_Synchronization","221343529_Bounds_on_Information_Exchange_for_Byzantine_Agreement","221233814_On_Self-stabilizing_Synchronous_Actions_Despite_Byzantine_Attacks","220431204_Bounds_on_Information_Exchange_for_Byzantine_Agreement","274012289_Towards_Optimal_Synchronous_Counting","269858936_Introduction_Self_Stabilization","234831006_Reaching_Agreement_in_the_Presence_of_Faults","220431719_Reaching_Agreement_in_the_Presence_of_Faults","220114448_A_Lower_Bound_for_the_Time_to_Assure_Interactive_Consistency","3501892_Towards_optimal_distributed_consensus","2246664_Self-Stabilizing_Clock_Synchronization_in_the_Presence_of_Byzantine_Faults"]}