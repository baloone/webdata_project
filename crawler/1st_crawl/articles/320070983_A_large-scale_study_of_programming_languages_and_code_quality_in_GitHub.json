{"id":"320070983_A_large-scale_study_of_programming_languages_and_code_quality_in_GitHub","abstract":"What is the effect of programming languages on software quality? This question has been a topic of much debate for a very long time. In this study, we gather a very large data set from GitHub (728 projects, 63 million SLOC, 29,000 authors, 1.5 million commits, in 17 languages) in an attempt to shed some empirical light on this question. This reasonably large sample size allows us to use a mixed-methods approach, combining multiple regression modeling with visualization and text analytics, to study the effect of language features such as static versus dynamic typing and allowing versus disallowing type confusion on software quality. By triangulating findings from different methods, and controlling for confounding effects such as team size, project size, and project history, we report that language design does have a significant, but modest effect on software quality. Most notably, it does appear that disallowing type confusion is modestly better than allowing it, and among functional languages, static typing is also somewhat better than dynamic typing. We also find that functional languages are somewhat better than procedural languages. It is worth noting that these modest effects arising from language design are overwhelmingly dominated by the process factors such as project size, team size, and commit size. However, we caution the reader that even these modest effects might quite possibly be due to other, intangible process factors, for example, the preference of certain personality types for functional, static languages that disallow type confusion.","authors":["Baishakhi Ray","Daryl Posnett","Premkumar Devanbu","Vladimir Filkov"],"meta":["September 2017Communications of the ACM 60(10):91-100","DOI:10.1145/3126905"],"references":["262317340_An_empirical_study_of_the_influence_of_static_type_systems_on_the_usability_of_undocumented_software","261119514_Do_static_type_systems_improve_the_maintainability_of_software_systems_An_empirical_study","227447300_Effects_of_Process_Maturity_on_Quality_Cycle_Time_and_Effort_in_Software_Product_Development","226435262_Selecting_Empirical_Methods_for_Software_Engineering_Research","221560133_Don't_Touch_My_Code_Examining_the_Effects_of_Ownership_on_Software_Quality","221308223_Identifying_Reasons_for_Software_Changes_using_Historic_Databases","220939042_Have_things_changed_now_An_empirical_study_of_bug_characteristics_in_modern_open_source_software","220277797_An_Empirical_Study_on_the_Influence_of_Pattern_Roles_on_Change-Proneness","3407306_Comparing_Programming_Paradigms_an_Evaluation_of_Functional_and_Object-Oriented_Programs","3188171_The_Confounding_Effect_of_Class_Size_on_the_Validity_of_Object-Oriented_Metrics","278723611_Cork","272294699_Programming_in_Scala","268247391_Applied_Statistics_using_SPSS_Statistica_and_Matlab","262250925_Empirical_Analysis_of_Programming_Language_Adoption","257559907_Bug_characteristics_in_open_source_software","254040895_Combining_functional_and_imperative_programming_for_multicore_software_An_empirical_study_evaluating_Scala_and_Java","248701790_Introduction_to_Probabilistic_Topic_Models","242424964_Applied_Multiple_RegressionCorrelation_Analysis_For_The_Behavioral_Sciences","234021438_Applied_Multiple_RegressionCorrelation_Analysis_For_The_Behavioral_Sciences","222459696_A_Theory_of_Type_Polymorphism_in_Programming","221554893_Assessing_Programming_Language_Impact_on_Development_and_Maintenance_A_Study_on_C_and_C","221321863_An_Experiment_About_Static_and_Dynamic_Type_Systems_Doubts_About_the_Positive_Impact_of_Static_Type_Systems_on_Development_Time","215519779_The_Principal_Type-Scheme_of_an_Object_in_Combinatory_Logic","213885836_The_principal_type-scheme_of_an_object_in_Combinatory_Logic"]}