{"id":"303011829_Dependent_types_and_multi-monadic_effects_in_F","abstract":"We present a new, completely redesigned, version of F∗, a language that works both as a proof assistant as well as a general-purpose, verification-oriented, effectful programming language. In support of these complementary roles, F? is a dependently typed, higher-order, call-by-value language with primitive effects including state, exceptions, divergence and IO. Although primitive, programmers choose the granularity at which to specify effects by equipping each effect with a monadic, predicate transformer semantics. F∗ uses this to efficiently compute weakest preconditions and discharges the resulting proof obligations using a combination of SMT solving and manual proofs. Isolated from the effects, the core of F∗ is a language of pure functions used to write specifications and proof terms-its consistency is maintained by a semantic termination check based on a well-founded order. We evaluate our design on more than 55,000 lines of F∗ we have authored in the last year, focusing on three main case studies. Showcasing its use as a general-purpose programming language, F∗ is programmed (but not verified) in F∗, and bootstraps in both OCaml and F#. Our experience confirms F∗'s pay-As-you-go cost model: writing idiomatic ML-like code with no finer specifications imposes no user burden. As a verification-oriented language, our most significant evaluation of F∗ is in verifying several key modules in an implementation of the TLS-1.2 protocol standard. For the modules we considered, we are able to prove more properties, with fewer annotations using F∗ than in a prior verified implementation of TLS-1.2. Finally, as a proof assistant, we discuss our use of F∗ in mechanizing the metatheory of a range of lambda calculi, starting from the simply typed lambda calculus to System Fw and even μF∗, a sizeable fragment of F∗ itself-these proofs make essential use of F∗'s flexible combination of SMT automation and constructive proofs, enabling a tactic-free style of programming and proving at a relatively large scale.","authors":["Nikhil Swamy","Markulf Kohlweiss","Jean-Karim Zinzindohoue","Santiago Zanella-Béguelin"],"meta":["April 2016ACM SIGPLAN Notices 51(1):256-270","DOI:10.1145/2837614.2837655","Conference: the 43rd Annual ACM SIGPLAN-SIGACT Symposium"],"references":["311474943_Effective_interactive_proofs_for_higher-order_imperative_programs","303969013_Equational_Reasoning_about_Programs_with_General_Recursion_and_Call-by-value_Semantics","266660663_Refinement_Types_For_Haskell","248801042_Towards_a_practical_programming_language_based_on_dependent_type_theory","234831806_Report_on_the_programming_language_EUCLID","231941988_Type-based_termination_of_recursive_definitions","227263348_Strongly_Typed_Term_Representations_in_Coq","221241152_Effective_Interactive_Proofs_for_Higher-Order_Imperative_Programs","221234895_Termination_of_Isabelle_Functions_via_Termination_of_Rewriting","221186740_Formalized_Metatheory_with_Terms_Represented_by_an_Indexed_Family_of_Types","220906571_Equational_Reasoning_about_Programs_with_General_Recursion_and_Call-by-value_Semantics","220676437_Hoare_type_theory_polymorphism_and_separation","3187946_Subtypes_for_specifications_predicate_subtyping_in_PVS","2645353_Reasoning_about_Aliasing","2641208_Monadic_Presentations_of_Lambda_Terms_Using_Generalized_Inductive_Types","2337811_Implementing_Mathematics_with_The_Nuprl_Proof_Development_System","325596243_Practical_foundations_for_programming_languages_second_edition","310446546_Mtac_A_monad_for_typed_tactic_programming_in_Coq","305054663_Authenticated-encryption_with_associated-data","303968855_Combining_Proofs_and_Programs_in_a_Dependently_Typed_Language","284000676_Extraction_in_Coq_An_Overview","283831366_Autosubst_Reasoning_with_de_Bruijn_Terms_and_Parallel_Substitutions","266859603_Why3_-_Where_Programs_Meet_Provers","262324458_Programming_and_Reasoning_with_Algebraic_Effects_and_Dependent_Types","262297069_Mtac_A_Monad_for_Typed_Tactic_Programming_in_Coq","262217536_Combining_Proofs_and_Programs_in_a_Dependently_Typed_Language","262175370_Verifying_Higher-order_Programs_with_the_Dijkstra_Monad","261960144_Refinement_types_for_Haskell","261310211_Implementing_TLS_with_Verified_Cryptographic_Security","248817776_Practical_Foundations_for_Programming_Languages","248036760_The_TLS_Transport_Layer_Security_Protocol","243609647_A_Polymorphic_Lambda-Calculus_with_Sized_Higher-Order_Types","225149162_Dafny_An_Automatic_Program_Verifier_for_Functional_Correctness","221609935_Authenticated-encryption_with_associated-data","221331659_Towards_a_Mathematical_Science_of_Computation","221186667_General_Recursion_in_Type_Theory","221186657_Subset_Coercions_in_Coq","220997248_Modular_verification_of_security_protocol_code_by_typing","220676480_Parameterised_notions_of_computation","213884232_Combining_programming_with_theorem_proving","200031684_Guarded_Commands_Nondeterminacy_and_Formal_Derivation_of_Programs","3501195_Computational_lambda-calculus_and_monads","2826882_Refinement_Types_for_ML_Tim_Freeman","2580968_Refinement_Types_for_ML","2574006_foetus_-_Termination_Checker_for_Simple_Functional_Programs","2448570_Cayenne_-_a_Language_With_Dependent_Types","2441141_Simple_General_Recursion_in_Type_Theory"]}