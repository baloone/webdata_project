{"id":"220997096_A_type-theoretic_foundation_for_programming_with_higher-order_abstract_syntax_and_first-class_substitutions","abstract":"syntax (HOAS) is a simple, powerful technique for implementing object languages, since it directly supports common and tricky routines dealing with variables, such as capture-avoiding substitution and renaming. This is achieved by representing binders in the object-language via binders in the meta-language. However, enriching functional programming languages with direct support for HOAS has been a major challenge, because recursion over HOAS encodings requires one to traverse lambda-abstractions and necessitates programming with open objects.\nWe present a novel type-theoretic foundation based on contextual modal types which allows us to recursively analyze open terms via higher-order pattern matching. By design, variables occurring in open terms can never escape their scope. Using several examples, we demonstrate that our framework provides a name-safe foundation to operations typically found in nominal systems. In contrast to nominal systems however, we also support capture-avoiding substitution operations and even provide first-class substitutions to the programmer. The main contribution of this paper is a syntax-directed bi-directional type system where we distinguish between the data language and the computation language together with the progress and preservation proof for our language.","authors":["Brigitte Pientka"],"meta":["January 2008ACM SIGPLAN Notices 43(1):371-382","DOI:10.1145/1328438.1328483","SourceDBLP","Conference: Proceedings of the 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2008, San Francisco, California, USA, January 7-12, 2008"],"references":["242387816_An_Extension_to_ML_to_Handle_Bound_Variables_in_Data_Structures_Preliminary_Report","231932704_Explicit_Substitutions","226492028_Primitive_recursion_for_higher-order_abstract_syntax","222559017_A_Meta_Linear_Logical_Framework","220613624_Contextual_modal_type_theory","32206546_Unification_Of_Simply_Typed_Lambda-Terms_As_Logic_Programming","2453450_A_Simply_Typed_Context_Calculus_With_First-Class_Environments","279401606_FreshML","252531922_Boxes_Go_Bananas_Encoding_Higher-Order_Abstract_Syntax_with_Parametric_Polymorphism","226783247_System_Description_Twelf_-_A_Meta-Logical_Framework_for_Deductive_Systems","223243851_Primitive_recursion_for_higher-order_abstract_syntax","222527162_A_Typed_Context_Calculus","221602569_Practical_Programming_with_Higher-Order_Encodings_and_Dependent_Types","221302553_A_Coverage_Checking_Algorithm_for_LF","220727384_The_nabla_-Calculus_Functional_Programming_with_Higher-Order_Encodings","220607067_A_Polymorphic_Environment_Calculus_and_its_Type-Inference_Algorithm","220606860_Computing_with_Contexts","220443868_Explicit_Environments","220178654_FreshML_Programming_with_Binders_Made_Simple","213882919_A_polymorphic_modal_type_system_for_Lisp-like_multi-staged_languages","35260627_Automating_the_Meta_Theory_of_Deductive_Systems","4263861_Static_name_control_for_FreshML","3811852_New_approach_to_abstract_syntax_involving_binders","2574029_Tabled_Higher-Order_Logic_Programming","2482725_Optimizing_Higher-Order_Pattern_Unification","2477163_A_concurrent_logical_framework_I_Judgments_and_properties","2378147_A_Framework_for_Defining_Logics"]}