{"id":"225205843_Transient_Fault_Detectors","abstract":"We present fault detectors for transient faults, (i.e., corruptions of the memory of the processors, but not of the code of\nthe processors). We distinguish fault detectors for tasks (i.e., the problem to be solved) from failure detectors for implementations (i.e., the algorithm that solves the problem). The aim of our fault detectors is to detect a memory corruption as soon as\npossible. We study the amount of memory needed by the fault detectors for some specific tasks, and give bounds for each task.\nThe amount of memory is related to the size and the number of views that a processor has to maintain to ensure a quick detection.\nThis work may give the implementation designer hints concerning the techniques and resources that are required for implementing\na task.","authors":["Joffroy Beauquier","Sylvie DelaÃ«t","Shlomi Dolev","Sebastien Tixeuil"],"meta":["July 2007Distributed Computing 20(1):39-51","DOI:10.1007/s00446-007-0029-x","SourceDBLP","Project: Self-Stabilization"],"references":["227296355_Self-stabilization_with_r-Operators_Revisited","226464111_Self_Stabilization_of_Dynamic_Systems_Assuming_Only_ReadWrite_Atomicity","225349554_Self-stabilization_with_r-operators","269858936_Introduction_Self_Stabilization","242409388_Memory-efficient_self-stabilization_on_general_networks","239593861_Distributed_Computing_A_Locality-Sensitive_Approach","239552157_Self_stabilizing_systems_in_spite_of_distributed_control","234799689_SELF-STABILIZATION_BY_LOCAL_CHECKING_AND_CORRECTION","229131941_Self-Stabilizing_Routing_and_Related_Protocols","225707516_Memory_requirements_for_silent_stabilization"]}