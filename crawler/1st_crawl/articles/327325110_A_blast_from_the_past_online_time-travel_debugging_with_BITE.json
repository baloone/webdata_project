{"id":"327325110_A_blast_from_the_past_online_time-travel_debugging_with_BITE","abstract":"Conventional back-in-time debuggers fashion a record and replay approach to facilitate inspecting all events in the past execution. This usually implies a significant performance overhead for tracing and storing information. Furthermore the recording only becomes available after the monitored code has terminated. In other words, conventional back-in-time-debuggers operate offline.\nIn this paper we present a novel approach of online back-in-time debugging, called Back-in-Time Evaluation (BITE). It offers the capabilities to evaluate code-snippets in the context of previous execution states. Thus, we can focus the trace recording on execution contexts accessible in online debugging, to meet the higher requirements for responsiveness of the debugger.\nFor this purpose, BITE only collects the results of operations that potentially yield different results when they are reevaluated. These are initially stored in the call frame of the executing method, which has a performance overhead of at most 5%. The downside is that once a frame is popped from the stack, the contained trace is disposed of as well. Therefore, BITE also allows to persist the trace collected in a frame before it is popped, at the cost of potentially increasing the overhead. The performance impact of this depends on the amount of trace information that needs to be persisted, as well as the strategy for storing this information. When storing the information in-memory, the overhead induced ranges from having no additional impact at all, up to a factor of 50x. Since memory capabilities are not unlimited, our approach allows for optionally serializing these objects. However, this induces a higher performance overhead.","authors":["Stefan Schulz","Christoph Bockisch"],"meta":["September 2018","DOI:10.1145/3237009.3237012","Conference: the 15th International Conference"],"references":["296675290_A_New_Hybrid_Debugging_Architecture_for_Eclipse","290602643_Studying_the_Advancement_in_Debugging_Practice_of_Professional_Software_Developers","262255794_Reusing_debugging_knowledge_via_trace-based_bug_search","234778038_The_DaCapo_Benchmarks_Java_Benchmarking_Development_and_Analysis","228556492_ASM_A_code_manipulation_tool_to_implement_adaptable_systems","225799901_Algorithmic_debugging_for_lazy_functional_languages","222522594_Algorithmic_Debugging_of_Java_Programs","221496481_Summarized_Trace_Indexing_and_Querying_for_Scalable_Back-in-Time_Debugging","221266794_Algorithmic_Debugging_for_Lazy_Functional_Languages","320391049_How_did_the_failure_come_to_be","318873927_RedShell_Online_Back-In-Time_Debugging","318873842_Back-In-Time_Evaluation_Towards_Online_Trace-Based_Debugging","305193550_Trace-based_debugging_for_advanced-dispatching_programming_languages","289093858_TARDIS_Affordable_time-travel_debugging_in_managed_runtimes","287947299_Hybrid_Debugging_of_Java_Programs","242383454_The_Java_Virtual_Machine_Specification_The_Java_Series","221553687_Angelic_debugging","220688559_JavaTM_Virtual_Machine_Specification","200040419_The_Java_Virtual_Machine_Specification-Second_Edition","34882266_Algorithmic_Program_Debugging","27297654_The_Debugging_Scandal_and_What_to_Do_About_It","1956777_Debugging_Backwards_in_Time"]}