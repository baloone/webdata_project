{"id":"278763240_Checking_foundational_proof_certificates_for_first-order_logic","abstract":"We present the design philosophy of a proof checker based on a notion of foundational proof certificates. At the heart of this design is a semantics of proof evidence that arises from recent advances in the theory of proofs for classical and intuitionistic logic. That semantics is then performed by a (higher-order) logic program: successful performance means that a formal proof of a theorem has been found. We describe how the λProlog programming language provides several features that help guarantee such a soundness claim. Some of these features (such as strong typing, abstract datatypes, and higher-order programming) were features of the ML programming language when it was first proposed as a proof checker for LCF. Other features of λProlog (such as support for bindings, substitution, and backtracking search) turn out to be equally important for describing and checking the proof evidence encoded in proof certificates. Since trusting our proof checker requires trusting a programming language implementation, we discuss various avenues for enhancing one's trust of such a checker.","authors":["Zakaria Chihani","Dale Miller","Fabien Renaud"],"meta":["June 2013","Project: ProofCert"],"references":["262157282_Foundational_Proof_Certificates_in_First-Order_Logic","254464415_LFP_-_A_Logical_Framework_with_External_Predicates","346825508_How_to_believe_a_machine-checked_proof","319394434_Higher-Order_Logic_Programming","319393698_A_Survey_of_the_Project_AUTOMATH","269009462_Programming_with_Higher-Order_Logic","267067214_Edinburgh_LCF_A_mechanized_logic_of_computation","257514569_Producing_and_verifying_extremely_large_propositional_refutations_Have_your_cake_and_eat_it_too","241859907_A_Survey_of_the_Project_Automath","239557390_A_unification_algorithm_for_typed_-calculus"]}