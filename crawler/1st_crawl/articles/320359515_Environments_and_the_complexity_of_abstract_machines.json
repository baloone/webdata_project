{"id":"320359515_Environments_and_the_complexity_of_abstract_machines","abstract":"machines for functional languages rely on the notion of environment, a data structure storing the previously encountered and delayed beta-redexes. This paper provides a close analysis of the different approaches to define and implement environments. There are two main styles. The most common one is to have many local environments, one for every piece of code in the data structures of the machine. A minority of works instead uses a single global environment. Up to now, the two approaches have been considered equivalent, in particular at the level of the complexity of the overhead: they have both been used to obtain bilinear bounds, that is, linear in the number of beta steps and in the size of the initial term.\nWe start by having a close look on global environments and how to implement them. Then we show that local environments admit implementations that are asymptotically faster than global environments, lowering the dependency from the size of the initial term from linear to logarithmic, thus improving the bounds in the literature. We then focus on a third style, split environments, that are in between local and global ones, and have the benefits of both. Finally, we provide a call-by-need machine with split environments for which we prove the new improved bounds on the overhead.","authors":["Beniamino Accattoli","Bruno Barras"],"meta":["October 2017","DOI:10.1145/3131851.3131855","Conference: the 19th International Symposium"],"references":["281487133_A_Strong_Distillery","228573290_Computing_with_Capsules","222426616_WRS_2008_New_Developments_in_Environment_Machines","221662597_On_the_Invariance_of_the_Unitary_Cost_Model_for_Head_Reduction_LongVersion","221351029_Lambda_Calculi_and_Linear_Speedups","221241347_A_Compiled_Implementation_of_Strong_Reduction","220676840_Deriving_a_Lazy_Abstract_Machine","220404275_Sequent_Calculi_and_Abstract_Machines","213879117_Improving_the_lazy_Krivine_machine","45908584_Lazy_Evaluation_and_Delimited_Control","2680525_The_Zinc_Experiment_An_Economical_Implementation_Of_The_Ml_Language","2639371_A_Natural_Semantics_for_Lazy_Evaluation","2597124_A_Call-By-Need_Lambda_Calculus","321146480_The_Negligible_and_Yet_Subtle_Cost_of_Pattern_Matching","320303413_Implementing_Open_Call-by-Value","319374245_Foundations_of_strong_call_by_need","312405324_On_the_Value_of_Variables","312025481_The_Complexity_of_Abstract_Machines","309092272_Classical_By-Need","308730809_On_the_Relative_Usefulness_of_Fireballs","305908655_The_Useful_MAM_a_Reasonable_Implementation_of_the_Strong_lambda_-Calculus","289587495_Leftmost-Outermost_Beta_Reduction_is_Invariant_Indeed","285906234_On_the_Value_of_Variables","276295899_On_the_Relative_Usefulness_of_Fireballs","272294886_Control_operators_the_SECD-machine_and_the_lambda-calculus","266660564_Distilling_Abstract_Machines","262270408_A_synthetic_operational_account_of_call-by-need_evaluation","257283539_Auto-validation_d'un_systeme_de_preuves_avec_familles_inductives","239564871_The_call-byneed_lambda_calculus","235624822_Semantics_and_Pragmatics_of_the_Lambda-Calculus","222565972_A_Functional_Correspondence_between_Call-by-Need_Evaluators_and_Lazy_Abstract_Machines","222120495_Call-by-name_call-by-value_and_the_l-calculus","220676764_Functional_Runtime_Systems_Within_the_Lambda-Sigma_Calculus","220607072_Strongly_reducing_variants_of_the_Krivine_abstract_machine","220606992_On_the_correctness_of_the_Krivine_machine","213882365_Control_operators_the_SECD-machine_and_the_lambda-calculus","213879084_Refocusing_in_Reduction_Semantics","213877823_The_Mechanical_Evaluation_of_Expressions","51990339_The_Call-by-Need_Lambda_Calculus_Revisited","46417134_A_call-by-name_lambda-calculus_machine","2798632_The_Coq_Proof_Assistant_-_Reference_Manual_V_510","2764863_Parallelism_in_Sequential_Functional_Languages","2339867_Purely_Functional_Random-Access_Lists"]}