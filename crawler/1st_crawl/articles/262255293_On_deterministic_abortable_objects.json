{"id":"262255293_On_deterministic_abortable_objects","abstract":"We define deterministic abortable (DA) objects, which guarantee that operations complete normally if executed solo, but may abort if executed concurrently with other operations. An operation that aborts has no effect on the object. This simple and attractive behavior is reminiscent of transactional memory, database transactions, and abortable mutual exclusion --- techniques in which a process can, under contention, ``bail out'' of the computation without leaving a trace.\nIt is well-known that ordinary objects can be placed in a consensus hierarchy, based on their ability to implement n-Consensus (an object that allows up to n processes to agree on a value): an object is at level n if, together with registers, it can implement n-Consensus} but not (n+1)-Consensus. We show that DA objects can be placed in an analogous hierarchy, called the DAC hierarchy, based on their ability to implement n-DAC, the DA counterpart of n-Consensus. We explore the similarities and differences between these two hierarchies.\nIt was previously known that 2-DAC is just as powerful as 2-Consensus, so the two hierarchies coincide at level 2. We show, however, that they diverge at higher levels. First, we show that ∞-DAC} (which is at level ∞ of the DAC hierarchy) can not implement even 3-Consensus (which is at level 3 of the consensus hierarchy). Then we show that, for each n, n-Consensus cannot implement (n+1)-DAC. Finally, we show that, in general, there is no simple correspondence between the level of an object in one hierarchy and its counterpart in the other: We exhibit an ordinary object at level ∞ of the consensus hierarchy, whose DA counterpart is at level 1 in the DAC hierarchy.","authors":["Vassos Hadzilacos","Sam Toueg"],"meta":["July 2013","DOI:10.1145/2484239.2484241","Conference: Proceedings of the 2013 ACM symposium on Principles of distributed computing"],"references":["234797651_A_completeness_theorem_for_a_class_of_synchronization_objects","229031766_Common2_extended_to_stacks_and_unbounded_concurrency","221643700_Scalable_queue-based_spin_locks_with_timeout","221343739_Common2_extended_to_stacks_and_unbounded_concurrency","220431045_Impossibility_of_Distributed_Consensus_with_One_Faulty_Process","220430796_On_the_Space_Complexity_of_Randomized_Synchronization","200030230_Linearizability_A_Correctness_Condition_for_Concurrent_Objects","37420864_Computing_with_Reads_and_Writes_in_the_Absence_of_Step_Contention","4017166_Obstruction-Free_Synchronization_Double-Ended_Queues_as_an_Example","3557037_Transactional_Memory_Architectural_Support_For_Lock-free_Data_Structures","2648040_Wait-Free_Synchronization","309456250_Wait-free_synchronization_ACM_Trans","269034177_Transactional_memory","239583375_Memory_requirements_for_agreement_among_unreliable_asynchronous_processes","226488797_Notes_on_Data_Base_Operating_Systems","221621885_Notes_on_Data_Base_Operating_Systems","221343885_Abortable_and_query-abortable_objects_and_their_efficient_implementation","221343304_A_Completeness_Theorem_for_a_Class_of_Synchronization_Objects_Extended_Abstract","221234033_Some_Results_on_the_Impossibility_Universality_and_Decidability_of_Consensus","200030199_Notes_on_Data_Base_Operating_Systems_Operating_Systems_An_Advanced_Course"]}