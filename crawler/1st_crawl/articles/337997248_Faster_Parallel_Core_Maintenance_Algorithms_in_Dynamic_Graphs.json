{"id":"337997248_Faster_Parallel_Core_Maintenance_Algorithms_in_Dynamic_Graphs","abstract":"This article studies the core maintenance problem for dynamic graphs which requires to update each vertex's core number with the insertion/deletion of vertices/edges. Previous algorithms can either process one edge associated with a vertex in each iteration or can only process one superior edge associated with the vertex (an edge 〈u; v〉 is a superior edge of vertex u if v' core number is no less than u's core number) in each iteration. Thus for high superior-degree vertices (the vertices associated with many superior edges) insertions/deletions, previous algorithms become very inefficient. In this article, we discovered a new structure called joint edge set whose insertions/deletions make each vertex's core number change at most one. The joint edge set mainly contains all the superior edges associated with the high superior-degree vertices as long as these vertices are 3\n<sup xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">+</sup>\n-hop independent. Based on this discovery, faster parallel algorithms are devised to solve the core maintenance problems. In our algorithms, we can process all edges in the joint edge set in one iteration and thus can greatly increase the parallelism and reduce the processing time. The results of extensive experiments conducted on various types of real-world, temporal, and synthetic graphs illustrate that the proposed algorithms achieve good efficiency, stability and scalability. Specifically, the new algorithms can outperform the single-edge processing algorithms by up to four orders of magnitude. Compared with the matching based algorithm and the superior edge based algorithm, our algorithms show a significant speedup up to 60× in the processing time.","authors":["Qiang-Sheng Hua","Yuliang Shi","Dongxiao Yu","Hai Jin"],"meta":["December 2019IEEE Transactions on Parallel and Distributed Systems PP(99):1-1","DOI:10.1109/TPDS.2019.2960226"],"references":["294731070_Incremental_k-core_decomposition_algorithms_and_evaluation","283471203_IO_Efficient_Core_Graph_Decomposition_at_Web_Scale","276079763_Identifying_important_classes_of_large_software_systems_through_K-core_decomposition","268227182_Finding_the_Hierarchy_of_Dense_Subgraphs_using_Nucleus_Decompositions","220906960_R-MAT_A_recursive_model_for_graph_mining","220489296_An_Om_Algorithm_for_Cores_Decomposition_of_Networks","220270138_Large_scale_networks_fingerprinting_and_visualization_using_the_k-core_decomposition","50855713_Distributed_k-Core_Decomposition","45898153_Identification_of_influential_spreaders_in_complex_networks","12779869_Albert_R_Emergence_of_Scaling_in_Random_Networks_Science_286_509-512","10953518_An_Automated_Method_for_Finding_Molecular_Complexes_in_Large_Protein_Interaction_Networks","6250104_A_Model_of_Internet_Topology_Using_k-shell_Decomposition","335572674_Incremental_Graph_Processing_for_On-line_Analytics","319468383_Learning_dynamic_dependency_network_structure_with_time_lag","318476013_Parallel_Algorithm_for_Core_Maintenance_in_Dynamic_Graphs","314943249_Core_Maintenance_in_Dynamic_Graphs_A_Parallel_Approach_Based_on_Matching","313609388_On_the_evolution_of_random_graphs","310821251_Finding_the_Hierarchy_of_Dense_Subgraphs_using_Nucleus_Decompositions","305446132_K-Core_decomposition_of_large_networks_on_a_single_PC","304456772_IO_efficient_Core_Graph_Decomposition_at_web_scale","303941791_Distributed_K-core_Decomposition_and_Maintenance_in_Large_Dynamic_Graphs","281996789_ParK_An_efficient_algorithm_for_k-core_decomposition_on_multicore_processors","265339534_Efficient_Core_Maintenance_in_Large_Dynamic_Graphs","224237578_Efficient_core_decomposition_in_massive_networks","2948228_The_WebGraph_Framework_I_Compression_Techniques"]}