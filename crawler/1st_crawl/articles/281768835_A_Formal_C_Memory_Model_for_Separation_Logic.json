{"id":"281768835_A_Formal_C_Memory_Model_for_Separation_Logic","abstract":"The core of a formal semantics of an imperative programming language is a\nmemory model that describes the behavior of operations on the memory. Defining\na memory model that matches the description of C in the C11 standard is\nchallenging because C allows both high-level (by means of typed expressions)\nand low-level (by means of bit manipulation) memory accesses. The C11 standard\nhas restricted the interaction between these two levels to make more effective\ncompiler optimizations possible, on the expense of making the memory model\ncomplicated.\nWe describe a formal memory model of the (non-concurrent part of the) C11\nstandard that incorporates these restrictions, and at the same time describes\nlow-level memory operations. This formal memory model includes a rich\npermission model to make it usable in separation logic and supports reasoning\nabout program transformations. The memory model and essential properties of it\nhave been fully formalized using the Coq proof assistant.","authors":["Robbert Krebbers"],"meta":["December 2016Journal of Automated Reasoning 57(4)","DOI:10.1007/s10817-016-9369-1","SourcearXiv"],"references":["281612280_Defining_the_Undefinedness_of_C","278769247_A_Precise_and_Abstract_Memory_Model_for_C_Using_Symbolic_Values","312721498_Separation_Algebras_for_C_Verification_in_Coq","311487967_Common_Compiler_Optimisations_are_Invalid_in_the_C11_Memory_Model_and_what_we_can_do_about_it","307757924_An_Intrinsic_Encoding_of_a_Subset_of_C_and_its_Application_to_TLS_Network_Packet_Processing","305268202_An_Algebraic_Semantics_of_Subobjects","301467840_A_Typed_C11_Semantics_for_Interactive_Theorem_Proving","295105242_The_Problem_of_Programming_Language_Concurrency_Semantics","290917405_Aliasing_Restrictions_of_C11_Formalized_in_Coq","282484786_A_Formal_C_Memory_Model_Supporting_Integer-Pointer_Casts"]}