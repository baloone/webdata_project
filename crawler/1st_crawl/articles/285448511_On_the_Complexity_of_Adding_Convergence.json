{"id":"285448511_On_the_Complexity_of_Adding_Convergence","abstract":"This paper investigates the complexity of designing Self-Stabilizing (SS) distributed programs, where an SS program meets two properties, namely closure and convergence. Convergence requires that, from any state, the computations of an SS program reach a set of legitimate states (a.k.a. invariant). Upon reaching a legitimate state, the computations of an SS program remain in the set of legitimate states as long as no faults occur; i.e., Closure. We illustrate that, in general, the problem of augmenting a distributed program with convergence, i.e., adding convergence, is NP-complete (in the size of its state space). An implication of our NP-completeness result is the hardness of adding nonmasking fault tolerance to distributed programs, which has been an open problem for the past decade.","authors":["Alex Klinkhamer","Ali Ebnenasir"],"meta":["April 2013","DOI:10.1007/978-3-642-40213-5_2","Conference: International Conference on Fundamentals of Software Engineering"],"references":["254037729_Swarm_Synthesis_of_Convergence_for_Symmetric_Protocols","228705176_SAT-based_synthesis_of_fault-tolerance","221039131_Revising_Distributed_UNITY_Programs_Is_NP-Complete","220951051_A_Lightweight_Method_for_Automated_Design_of_Convergence","220102545_Transformation_of_Programs_for_Fault-Tolerance","220080721_An_approach_to_synthesise_safe_systems","34965464_Automatic_synthesis_of_fault-tolerance","4080095_Automated_synthesis_of_multitolerance","3449363_Complexity_Issues_in_Automated_Synthesis_of_Failsafe_Fault-Tolerance","3187942_Designing_masking_fault-tolerance_via_nonmasking_fault-tolerance","2441410_Lecture_Notes_in_Computer_Science","337739687_Constraint_satisfaction_as_a_basis_for_designing_nonmasking_fault-tolerance","284878825_Automating_the_addition_of_fault-tolerance","244954154_A_Computing_Procedure_for_Quantification_Theory","242611475_Automated_Design_of_Ecient_Fail-Safe_Fault_Tolerance","242542144_A_foundation_of_fault-tolerant_computing","239552157_Self_stabilizing_systems_in_spite_of_distributed_control","234799689_SELF-STABILIZATION_BY_LOCAL_CHECKING_AND_CORRECTION","234793529_Distributed_Computing_Models_and_Methods","222552177_Stabilization-Preserving_Atomicity_Refinement","222450697_Defining_liveness","221278206_The_Theory_of_Weak_Stabilization","221234203_The_Triumph_and_Tribulation_of_System_Stabilization","220695897_A_Discipline_of_Programming","220695890_Computers_and_Intracdtability_A_Guide_to_the_Theory_of_NP-Completeness","220423523_Dijkstra_EW_Self-stabilizing_Systems_in_Spite_of_Distributed_Control_ACM_Commun_1711_643-644","220152965_Automated_constraint-based_addition_of_nonmasking_and_stabilizing_fault-tolerance","4259748_Exploiting_Symbolic_Techniques_in_Automated_Synthesis_of_Distributed_Programs_with_Large_State_Space","3960240_Convergence_refinement","3560718_Constraint_satisfaction_as_a_basis_for_designing_nonmasking_fault-tolerance","3513283_Closure_and_convergence_a_formulation_of_fault-tolerant_computing","3510367_Self-stabilization_by_local_checking_and_correction","3187618_Closure_and_Convergence_A_Foundation_of_Fault-Tolerant_Computing","2508189_Constraint_Satisfaction_as_a_Basis_for_Designing_Nonmasking_Fault-Tolerance","2386879_Convergence_Refinement"]}