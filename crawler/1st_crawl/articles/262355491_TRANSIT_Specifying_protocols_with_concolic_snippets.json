{"id":"262355491_TRANSIT_Specifying_protocols_with_concolic_snippets","abstract":"With the maturing of technology for model checking and constraint solving, there is an emerging opportunity to develop programming tools that can transform the way systems are specified. In this paper, we propose a new way to program distributed protocols using concolic snippets. Concolic snippets are sample execution fragments that contain both concrete and symbolic values. The proposed approach allows the programmer to describe the desired system partially using the traditional model of communicating extended finite-state-machines (EFSM), along with high-level invariants and concrete execution fragments. Our synthesis engine completes an EFSM skeleton by inferring guards and updates from the given fragments which is then automatically analyzed using a model checker with respect to the desired invariants. The counterexamples produced by the model checker can then be used by the programmer to add new concrete execution fragments that describe the correct behavior in the specific scenario corresponding to the counterexample.\nWe describe TRANSIT, a language and prototype implementation of the proposed specification methodology for distributed protocols. Experimental evaluations of TRANSIT to specify cache coherence protocols show that (1) the algorithm for expression inference from concolic snippets can synthesize expressions of size 15 involving typical operators over commonly occurring types, (2) for a classical directory-based protocol, TRANSIT automatically generates, in a few seconds, a complete implementation from a specification consisting of the EFSM structure and a few concrete examples for every transition, and (3) a published partial description of the SGI Origin cache coherence protocol maps directly to symbolic examples and leads to a complete implementation in a few iterations, with the programmer correcting counterexamples resulting from underspecified transitions by adding concrete examples in each iteration.","authors":["Abhishek Udupa","Arun Raghavan","Jyotirmoy Deshmukh","Sela Mador-Haim"],"meta":["June 2013ACM SIGPLAN Notices 48(6):287-296","DOI:10.1145/2491956.2462174","Conference: Proceedings of the 34th ACM SIGPLAN conference on Programming language design and implementationVolume: 48"],"references":["221560458_CUTE_A_concolic_unit_testing_engine_for_C","221027106_MCGP_A_Software_Synthesis_Tool_Based_on_Model_Checking_and_Genetic_Programming","220244809_Multifacet's_general_execution-driven_multiprocessor_simulator_GEMS_toolset","4162282_Automatic_synthesis_of_cache-coherence_protocol_processors_using_Bluespec","4023265_So_Many_States_So_Little_Time_Verifying_Memory_Coherence_in_the_Cray_X1","2811215_Verification_of_the_Futurebus_Cache_Coherence_Protocol","278646722_CUTE","268238894_The_SGI_Origin","262220469_Behavioral_programming","245954051_Distributed_Algorithms_Chapter_6_7","221570346_Facets_of_Synthesis_Revisiting_Church's_Problem","221560478_Synthesizing_data-structure_manipulations_from_storyboards","221555359_Oracle-guided_component-based_program_synthesis","221550948_Lazy_Synthesis","220997927_From_Program_Verification_to_Program_Synthesis","220997384_Automating_String_Processing_in_Spreadsheets_Using_Input-Output_Examples","220884397_Going_with_the_Flow_Parameterized_Verification_Using_Message_Flows","220752103_Synthesis_of_Loop-free_Programs","220751823_Sketching_concurrent_data_structures","220695682_The_Spin_Model_Checker_Primer_and_Reference_Manual","220694631_Come_let's_play_-_scenario-based_programming_using_LSCs_and_the_play-engine","220425501_Software_Synthesis_Procedures","213883482_Programming_by_sketching_for_bit-streaming_programs","51978447_Sciduction_Combining_Induction_Deduction_and_Structure_forVerification_and_Synthesis","3700198_The_SGI_origin_a_ccNUMA_highly_scalable_server","2962093_Can_Programming_Be_Liberated_Period","2333731_Protocol_Verification_as_a_Hardware_Design_Aid"]}