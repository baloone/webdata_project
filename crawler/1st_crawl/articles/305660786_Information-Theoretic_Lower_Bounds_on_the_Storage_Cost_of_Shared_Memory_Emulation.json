{"id":"305660786_Information-Theoretic_Lower_Bounds_on_the_Storage_Cost_of_Shared_Memory_Emulation","abstract":"The focus of this paper is to understand storage costs of emulating an atomic shared memory over an asynchronous, distributed message passing system. Previous literature has developed several shared memory emulation algorithms based on replication and erasure coding techniques, and analyzed the storage costs of the proposed algorithms. In this paper, we present the first known information-theoretic lower bounds on the storage costs incurred by shared memory emulation algorithms. Our storage cost lower bounds are universally applicable, that is, we make no assumption on the structure of the algorithm or the method of encoding the data.\nWe consider an arbitrary algorithm A that implements an atomic multi-writer-single-reader (MWSR) shared memory variable whose values come from a finite set V over a system of N servers connected by point-to-point asynchronous links. We require that in every fair execution of algorithm A where the number of server failures is smaller than a parameter f, every operation invoked at a non-failing client terminates. We define the storage cost of a server in algorithm A as the logarithm (to base 2) of the number of states it can take on; the total storage cost of algorithm A is the sum of the storage cost of all servers. Previously, it was known that the storage cost cannot be smaller than N/N?f log2 |V|.We develop three new lower bounds on the storage cost of algorithm A.\nIn our first lower bound, we show that if algorithm A does not use server gossip, then the total storage cost is lower bounded by 2 N/N-f+1}log2|V|--o(log2|V|).\nIn our second lower bound we show that the total storage cost is at least 2 N/N-f+2} log2|V|--o(log2|V|) even if the algorithm uses server gossip.\nIn our third lower bound, we consider algorithms where the write protocol sends information about the value in at most one phase. For such algorithms, we show that the total storage cost is at least v* N/N-f+v*-1 log2 (|V|)-- o(log2(|V|), where v* is the minimum of f+1 and the number of active write operations of an execution.\nOur first and second lower bounds are approximately twice as strong as the previously known bound of N/N-f log2|V|}. Furthermore, our first two lower bounds apply even for regular, single-writer single-reader (SWSR) shared memory emulation algorithms. Our third lower bound is much larger than our first and second lower bounds, although it is applicable to a smaller class of algorithms where the write protocol has certain restrictions. In particular, our third bound is comparable to the storage cost achieved by most shared memory emulation algorithms in the literature, which naturally fall under the class of algorithms studied. Our proof ideas are inspired by recent results in coding theory.","authors":["Viveck Cadambe","Zhiying Wang","Nancy Lynch"],"meta":["May 2016","DOI:10.1145/2933057.2933118","Conference: the 2016 ACM Symposium"],"references":["318412374_Multi-Version_Coding_-_An_Information-Theoretic_Perspective_of_Consistent_Distributed_Storage","303957499_A_coded_shared_atomic_memory_algorithm_for_message_passing_architectures","264005552_A_Coded_Shared_Atomic_Memory_Algorithm_for_Message_Passing_Architectures","260295079_Erasure-Coded_Byzantine_Storage_with_Separate_Metadata","236157522_Error_Control_Coding","233917764_Proofs_of_Writing_for_Efficient_and_Robust_Storage","224168195_Network_Coding_for_Distributed_Storage_Systems","221343320_Sharing_Memory_Robustly_in_Message-Passing_Systems","220938897_FAB_Building_distributed_enterprise_disk_arrays_from_commodity_components","220618002_Multiwriter_Consistency_Conditions_for_Shared_Memory_Registers","220430286_Sharing_Memory_Robustly_in_Message-Passing_Systems","200030230_Linearizability_A_Correctness_Condition_for_Concurrent_Objects","37450316_Amnesic_Distributed_Storage","23595136_A_case_for_Redundant_Arrays_of_Inexpensive_Disks_RAID","2938906_FAB_Building_Distributed_Enterprise_Disk_Arrays_from","349214756_FAB_building_distributed_enterprise_disk_arrays_from_commodity_components","313562977_Sharing_memory_robustly_in_message_passing_systems","305660699_Space_Bounds_for_Reliable_Storage_Fundamental_Limits_of_Coding","305262216_A_Case_for_Redundant_Arrays_of_Inexpensive_Disks_RAID","281084462_Space_Bounds_for_Reliable_Multi-Writer_Data_Store_Inherent_Cost_of_ReadWrite_Primitives","280243529_Space_Bounds_for_Reliable_Storage_Fundamental_Limits_of_Coding","278687565_FAB","269269702_Multi-Version_Coding_in_Distributed_Storage","262371993_What_can_coding_theory_do_for_storage_systems","235008707_Intoduction_to_Coding_Theory","227178201_Optimistic_Erasure-Coded_Distributed_Storage","225453877_Efficient_Replication_of_Large_Data_Objects","221233928_Optimistic_Erasure-Coded_Distributed_Storage","220910250_Low-overhead_byzantine_fault-tolerant_storage","220566925_On_Interprocess_Communication_Part_I_Basic_Formalism","200031719_Impossibility_of_Distributed_Consensus_with_One_Faulty_Process","4243371_Optimal_Resilience_for_Erasure-Coded_Byzantine_Distributed_Storage","4156622_Using_Erasure_Codes_Efficiently_for_Storage_in_a_Distributed_System"]}