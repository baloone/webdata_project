{"id":"292449753_Customising_compilers_for_customisable_processors","abstract":"The automatic generation of instruction set extensions to provide application-specific acceleration\nfor embedded processors has been a productive area of research in recent years. There\nhave been incremental improvements in the quality of the algorithms that discover and select\nwhich instructions to add to a processor. The use of automatic algorithms, however, result in\ninstructions which are radically different from those found in conventional, human-designed,\nRISC or CISC ISAs. This has resulted in a gap between the hardware’s capabilities and the\ncompiler’s ability to exploit them.\nThis thesis proposes and investigates the use of a high-level compiler pass that uses graph-subgraph\nisomorphism checking to exploit these complex instructions. Operating in a separate\npass permits techniques to be applied that are uniquely suited for mapping complex instructions,\nbut unsuitable for conventional instruction selection. The existing, mature, compiler\nback-end can then handle the remainder of the compilation. With this method, the high-level\npass was able to use 1965 different automatically produced instructions to obtain an initial average\nspeed-up of 1.11x over 179 benchmarks evaluated on a hardware-verified cycle-accurate\nsimulator.\nThis result was improved following an investigation of how the produced instructions were\nbeing used by the compiler. It was established that the models the automatic tools were using to\ndevelop instructions did not take account of how well the compiler could realistically use them.\nAdding additional parameters to the search heuristic to account for compiler issues increased\nthe speed-up from 1.11x to 1.24x. An alternative approach using a re-designed hardware interface\nwas also investigated and this achieved a speed-up of 1.26x while reducing hardware and\ncompiler complexity.\nA complementary, high-level, method of exploiting dual memory banks was created to increase\nmemory bandwidth to accommodate the increased data-processing bandwidth provided\nby extension instructions. Finally, the compiler was considered for use in a non-conventional\nrole where rather than generating code it is used to apply source-level transformations prior to\nthe generation of extension instructions and thus affect the shape of the instructions that are\ngenerated.","authors":["Alastair Colin Murray"],"meta":["November 2012"],"references":[]}