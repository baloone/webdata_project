{"id":"326164155_Verified_compilation_of_linearizable_data_structures_mechanizing_rely_guarantee_for_semantic_refinement","abstract":"Compiling concurrent and managed languages involves implementing sophisticated interactions between client code and the runtime system. An emblematic runtime service, whose implementation is particularly error-prone, is concurrent garbage collection. In a recent work [31], we implement an on-the-fly concurrent garbage collector, and formally prove its functional correctness in the Coq proof assistant. The garbage collector is implemented in a compiler intermediate representation featuring abstract concurrent data structures.\nThe present paper extends this work by considering the concrete implementation of some of these abstract concurrent data structures. We formalize, in the Coq proof assistant, a theorem establishing the semantic correctness of a compiling pass which translates abstract, atomic data structures into their concrete, fine-grained concurrent implementations.\nAt the crux of the proof lies a generic result establishing once and for all a simulation relation, starting from a carefully crafted rely-guarantee specification. Inspired by the work of Vafeiadis [28], implementations are annotated with linearization points. Semantically, this instrumentation reflects the behavior of abstract data structures.","authors":["Yannick Zakowski","David Cachera","Delphine Demange","David Pichardie"],"meta":["April 2018","DOI:10.1145/3167132.3167333","Conference: the 33rd Annual ACM Symposium"],"references":["282485043_Relaxing_Safely_Verified_On-the-Fly_Garbage_Collection_for_x86-TSO","267338850_Verifying_linearizability_A_comparative_survey","266657665_Atomicity_Refinement_for_Verified_Compilation","242488657_Modular_fine-grained_concurrency_verification","221602457_Abstraction_for_Concurrent_Objects","221331334_Specification_and_Design_of_Parallel_Programs","221032952_Implementing_an_On-the-Fly_Garbage_Collector_for_Java","220102424_A_Mechanically_Verified_Incremental_Garbage_Collector","213876653_The_Art_of_Multiprocessor_Programming","200030230_Linearizability_A_Correctness_Condition_for_Concurrent_Objects","24000534_A_Formally_Verified_Compiler_Back-end","2612162_Mechanical_Verification_of_a_Garbage_Collector","2593287_A_Mechanized_Refinement_Proof_for_a_Garbage_Collector","325142264_Mechanized_Verification_of_Fine-Grained_Concurrent_Programs","319203038_Verifying_a_Concurrent_Garbage_Collector_Using_a_Rely-Guarantee_Methodology","315487499_Closing_the_Gap_-_The_Formally_Verified_Optimizing_Compiler_CompCert","314795011_Accurate_garbage_collection_in_an_uncooperative_environment","300645984_Automated_and_Modular_Refinement_Reasoning_for_Concurrent_Programs","282926793_Iris_Monoids_and_Invariants_as_an_Orthogonal_Basis_for_Concurrent_Reasoning","282350557_Verifying_Linearisability","262290050_Modular_Verification_of_Linearizability_with_Non-Fixed_Linearization_Points","262241915_Rely-Guarantee-Based_Simulation_for_Compositional_Verification_of_Concurrent_Program_Transformations","239579778_Systems_programming_coping_with_parallelism","222992017_A_scalable_lock-free_stack_algorithm","222398178_Abstraction_for_Concurrent_Objects","221602562_On_the_Relationship_Between_Concurrent_Separation_Logic_and_Assume-Guarantee_Reasoning","221403288_Verifying_the_Safety_of_a_Practical_Concurrent_Garbage_Collector","220700351_A_Marriage_of_RelyGuarantee_and_Separation_Logic","220404317_Mechanically_Verified_Proof_Obligations_for_Linearizability","220104626_Accurate_garbage_collection_in_uncooperative_environments_revisited","45913328_Automated_Verification_of_Practical_Garbage_Collectors","2888551_Resources_Concurrency_and_Local_Reasoning","2534950_Accurate_Garbage_Collection_in_an_Uncooperative_Environment"]}