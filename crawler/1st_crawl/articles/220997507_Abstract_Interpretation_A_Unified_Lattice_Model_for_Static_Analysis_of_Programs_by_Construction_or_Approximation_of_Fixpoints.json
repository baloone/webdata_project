{"id":"220997507_Abstract_Interpretation_A_Unified_Lattice_Model_for_Static_Analysis_of_Programs_by_Construction_or_Approximation_of_Fixpoints","abstract":"A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).","authors":["Patrick Cousot","Radhia Cousot"],"meta":["January 1977","DOI:10.1145/512950.512973","SourceDBLP","Conference: Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages"],"references":["237107559_Towards_a_Mathematical_Semantics_for_Computer_Languages","267090337_Fixpoint_induction_and_proofs_of_program_properties","239004938_Type_determination_for_very_high_level_languages","238681140_Surface_properties_of_programming_language_constructs","234799332_Automatic_Data_Structure_Choice_in_a_Language_of_Very_High_Level","227212608_Checking_of_operand_types_in_algol_compilers","227098471_Consistent_and_complementary_formal_theories_of_the_semantics_of_programming_languages","220898827_Eliminating_Blind_Alleys_from_Backtrack_Programs","220198197_Monotone_Data_Flow_Analysis_Frameworks","220070460_Property_Extraction_in_Well-Founded_Property_Sets"]}