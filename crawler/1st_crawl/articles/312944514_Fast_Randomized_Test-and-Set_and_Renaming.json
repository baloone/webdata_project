{"id":"312944514_Fast_Randomized_Test-and-Set_and_Renaming","abstract":"Most people believe that renaming is easy: simply choose a name \\emph{at random}; if more than one process selects the same name, then try again. We highlight the issues that occur when trying to implement such a scheme and shed new light on the read-write complexity of randomized renaming in an asynchronous environment. At the heart of our new perspective stands an adaptive implementation of a randomized test-and-set object, that has poly-logarithmic step complexity per operation, with high probability. Interestingly, our implementation is anonymous, as it does not require process identifiers. Based on this implementation, we present two new randomized renaming algorithms. The first ensures a tight namespace of $n$ names using $O( n \\log^4 n)$ total steps, with high probability. This improves on the best previously known namespace-optimal algorithm by almost a quadratic factor. The second algorithm achieves a namespace of size $k (1 + \\epsilon)$ using $O( k \\log^4 k / \\log^2 (1 + \\epsilon) )$ total steps, both with high probability, where $k$ is the total contention in the execution. It is the first \\emph{adaptive} randomized renaming algorithm, and it improves on existing deterministic solutions by providing a smaller namespace, and by lowering complexity.","authors":["Dan Alistarh","Hagit Attiya","Andrei Giurgiu","Seth Gilbert"],"meta":["January 2010"],"references":["234819920_Shavit_N_The_Topological_Structure_of_Asynchronous_Computability_Journal_of_the_ACM_466_858-923","234796459_Fast_wait-free_2_k_-1-renaming","227311486_Fully-Adaptive_Algorithms_for_Long-Lived_Renaming","225789871_Fast_long-lived_renaming_improved_and_simplified","225711833_Randomized_Two-Process_Wait-Free_Test-and-Set","225419374_The_Complexity_of_Synchronous_Iterative_Do-All_with_Crashes","221343913_Fast_Long-Lived_Renaming_Improved_and_Simplified_Abstract","221233720_Wait-free_Test-and-Set_Extended_Abstract","220566884_Efficient_adaptive_collect_using_randomization","200030230_Linearizability_A_Correctness_Condition_for_Concurrent_Objects","47842800_Randomized_Naming_Using_Wait-Free_Shared_Variables","2728868_Using_Local-Spin_k-Exclusion_Algorithms_to_Improve_Wait-Free_Object_Implementations","2648040_Wait-Free_Synchronization","296815828_Adaptive_mutual_exclusion_with_local_spinning","234816293_Immediate_atomic_snapshots_and_fast_renaming","234801798_Ambiguity_of_choosing","232652448_Randomized_consensus_in_expected_On_logsup_2_n_operations_per_processor_PDF","228057840_Randomized_Algorithms","221669789_Probability_and_Computing_Randomized_Algorithms_and_Probabilistic_Analysis","221498266_Randomized_Consensus_in_Expected_ONlog_2_N_Operations_Per_Processor","221344306_Asynchronous_Exclusive_Selection","221343909_Immediate_Atomic_Snapshots_and_Fast_Renaming_Extended_Abstract","221343462_New_Combinatorial_Topology_Upper_and_Lower_Bounds_for_Renaming","221257181_Writing-all_deterministically_and_optimally_using_a_non-trivial_number_of_asynchronous_processors","221234107_Long-Lived_Fast_Waitfree_Renaming_with_Optimal_Name_Space_and_High_Throughput","221233821_Fast_Long-Lived_Renaming_Extended_Abstract","220688221_Do-All_Computing_in_Distributed_Systems_Cooperation_in_the_Presence_of_Adversity","220432418_Tight_bounds_for_asynchronous_randomized_consensus","220431501_Renaming_in_an_Asynchronous_Environment","200031719_Impossibility_of_Distributed_Consensus_with_One_Faulty_Process","2434268_Adaptive_And_Efficient_Algorithms_For_Lattice_Agreement_And_Renaming","2331658_Adaptive_Mutual_Exclusion_with_Local_Spinning"]}