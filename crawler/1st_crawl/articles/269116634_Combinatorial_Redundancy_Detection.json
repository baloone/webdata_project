{"id":"269116634_Combinatorial_Redundancy_Detection","abstract":"The problem of detecting and removing redundant constraints is fundamental in\noptimization. We focus on the case of linear programs (LPs) in dictionary form,\ngiven by $n$ equality constraints in $n+d$ variables, where the variables are\nconstrained to be nonnegative. A variable $x_r$ is called redundant, if after\nremoving $x_r \\geq 0$ the LP still has the same feasible region. The time\nneeded to solve such an LP is denoted by $LP(n,d)$.\nIt is easy to see that solving $n+d$ LPs of the above size is sufficient to\ndetect all redundancies. The currently fastest practical method is the one by\nClarkson: it solves $n+d$ linear programs, but each of them has at most $s$\nvariables, where $s$ is the number of nonredundant constraints.\nIn the first part we show that knowing all of the finitely many dictionaries\nof the LP is sufficient for the purpose of redundancy detection. A dictionary\nis a matrix that can be thought of as an enriched encoding of a vertex in the\nLP. Moreover - and this is the combinatorial aspect - it is enough to know only\nthe signs of the entries, the actual values do not matter. Concretely we show\nthat for any variable $x_r$ one can find a dictionary, such that its sign\npattern is either a redundancy or nonredundancy certificate for $x_r$.\nIn the second part we show that considering only the sign patterns of the\ndictionary, there is an output sensitive algorithm of running time\n$\\mathcal{O}(d \\cdot (n+d) \\cdot s^{d-1} \\cdot LP(s,d) + d \\cdot s^{d} \\cdot\nLP(n,d))$ to detect all redundancies. In the case where all constraints are in\ngeneral position, the running time is $\\mathcal{O}(s \\cdot LP(n,d) + (n+d)\n\\cdot LP(s,d))$, which is essentially the running time of the Clarkson method.\nOur algorithm extends naturally to a more general setting of arrangements of\noriented topological hyperplane arrangements.","authors":["Komei Fukuda","Bernd GÃ¤rtner","May Szedlak"],"meta":["June 2018Annals of Operations Research 265(1)","DOI:10.1007/s10479-016-2385-z","SourcearXiv"],"references":["331820198_Enumerating_Extreme_Points_in_Higher_Dimensions","324345426_Linear_Programming","312914534_An_algorithm_for_identifying_the_frame_of_a_pointed_finite_conical_hull","274238501_Linear_Programming_and_Extensions","268861093_A_finite_conformal-elimination_free_algorithm_over_oriented_matroid_programming","268736092_Lineare_Programmierung_und_Erweiterungen","259967558_Oriented_Matroids","246163746_FAQ_in_polyhedral_computation","238508338_Introduction_to_Optimization_with_Exact_Arithmetic","231890137_The_Maximum_Numbers_of_Faces_of_a_Convex_Polytope"]}