{"id":"323410289_Evaluating_and_Tuning_n-fold_Integer_Programming","abstract":"In recent years, algorithmic breakthroughs in stringology, computational social choice, scheduling, and so on, were achieved by applying the theory of so-called n-fold integer programming. An n-fold integer program (IP) has a highly uniform block structured constraint matrix. Hemmecke, Onn, and Romanchuk [Math. Program., 2013] showed an algorithm with runtime ΔO(rst + r2s)n³, where Δ is the largest coefficient, r,s, and t are dimensions of blocks of the constraint matrix and n is the total dimension of the IP; thus, an algorithm efficient if the blocks are of small size and with small coefficients. The algorithm works by iteratively improving a feasible solution with augmenting steps, and n-fold IPs have the special property that augmenting steps are guaranteed to exist in a not-too-large neighborhood. However, this algorithm has never been implemented and evaluated.\nWe have implemented the algorithm and learned the following along the way. The original algorithm is practically unusable, but we discover a series of improvements that make its evaluation possible. Crucially, we observe that a certain constant in the algorithm can be treated as a tuning parameter, which yields an efficient heuristic (essentially searching in a smaller-than-guaranteed neighborhood). Furthermore, the algorithm uses an overly expensive strategy to find a “best” step, while finding only an “approximately best” step is much cheaper, yet sufficient for quick convergence. Using this insight, we improve the asymptotic dependence on n from n³ to n² log n.\nFinally, we tested the behavior of the algorithm with various values of the tuning parameter and different strategies of finding improving steps. First, we show that decreasing the tuning parameter initially leads to an increased number of iterations needed for convergence and eventually to getting stuck in local optima, as expected. However, surprisingly small values of the parameter already exhibit good behavior while significantly lowering the time the algorithm spends per single iteration. Second, our new strategy for finding “approximately best” steps wildly outperforms the original construction.","authors":["Kateřina Altmanová","Dusan Knop","Martin Koutecký"],"meta":["February 2018Journal of Experimental Algorithmics 24(1)","DOI:10.1145/3330137","Project: Implementation of a solver for n-fold Integer Programing"],"references":["323257086_A_Parameterized_Strongly_Polynomial_Algorithm_for_Block_Structured_Integer_Programs","322662872_Covering_a_tree_with_rooted_subtrees-parameterized_and_approximation_algorithms","317101064_Combinatorial_n-fold_Integer_Programming_and_Applications","301839252_Scheduling_meets_n-fold_Integer_Programming","346637897_Near-Linear_Time_Algorithm_for_n-Fold_ILPs_via_Color_Coding","342373569_Voting_and_Bribing_in_Single-Exponential_Time","323276634_Faster_Algorithms_for_Integer_Programs_with_Block_Structure","322634368_Empowering_the_Configuration-IP_-_New_PTAS_Results_for_Scheduling_with_Setups_Times","322218352_Covering_a_tree_with_rooted_subtrees_-_parameterized_and_approximation_algorithms","316235514_Jupyter_Notebooks_-_a_publishing_format_for_reproducible_computational_workflows"]}