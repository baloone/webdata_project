{"id":"251351298_Clique_is_hard_to_approximate_within","abstract":"The basic entity in complexity theory is a computational problem which, from a mathematical point of view, is simply a function F from finite binary strings to finite binary strings. To make some functions more intuitive these finite binary strings should sometimes be interpreted as integers, graphs, or descriptions of polynomials. An important special case is given by decision problems where the range consists of only two strings usually taken to be 0 or 1. A function F should be realized by an algorithm and there are many ways to mathematically formalize the notion of an algorithm. One of the first formalizations which is still heavily used is that of a Turing machine. However, since we in this paper do not deal with the fine details of the definition, the reader might as well think of a standard computer with a standard programming language. The only idealization needed is that the computer contains an infinite number of words of memory, each of which remains of bounded size. The algorithm has some means of reading information from the external world and also some mechanism to write the result. Time is measured as the number of elementary steps. A finite binary string x in the domain is simply called the input, while the output is the final result of the computation delivered to the outside world. An algorithm solves the computational problem F if, when presented x on its input device, it produces output F(x). A parameter that is important to measure the performance of the algorithm is the length of the input which simply is the number of binary symbols in x. In complexity theory the basic notion of efficiently computable is defined as computable in time polynomial in the input length. The class of polynomial-time solvable decision problems is denoted by P. Establishing that a problem cannot be solved efficiently can sometimes be done but for most naturally occurring computational problems of combinatorial nature, no such bounds are known. Many such problems fall into the","authors":["Johan HÃ¥stad"],"meta":["March 1999Acta Mathematica 182(1):105-142","DOI:10.1007/BF02392825"],"references":["234794393_Proof_Verification_and_the_Hardness_of_Approximation_Problems","234783217_Interactive_proofs_and_the_hardness_of_approximating_cliques","228057672_Approximating_maximum_independent_sets_by_excluding_subgraphs","221591954_Efficient_probabilistically_checkable_proofs_and_applications_to_approximations","221591362_Multi-Prover_Interactive_Proofs_How_to_Remove_Intractability_Assumptions","221499638_Non-Deterministic_Exponential_Time_Has_Two-Prover_Interactive_Protocols","220616954_Free_Bits_PCPs_and_Nonapproximability-Towards_Tight_Results","3635328_Free_Bits_PCPs_and_Non-Approximability_-_Towards_Tight_Results","3505583_Algebraic_Methods_for_Interactive_Proof_Systems","3505565_Nondeterministic_exponential_time_has_two-prover_interactiveprotocols","3079137_Linearity_Testing_in_Characteristic_Two","2607238_Algebraic_Methods_for_Interactive_Proof_Systems","313185557_On_the_complexity_of_approximating_the_independent_set_problem","273674251_The_Knowledge_Complexity_of_Interactive_Proof_Systems","265359986_Walsh_subspaces_of_L_p_-product_spaces","248753193_Multi-prover_interactive_proofs_how_to_remove_intractability","232619366_Clique_is_hard_to_approximate_within_n1_-_E","228057894_Computational_Complexity","228057892_Optimization_approximation_and_complexity_classes","228057840_Randomized_Algorithms","228057776_Approximation_Algorithms_for_Combinatorial_Problems","228057735_Computers_And_Intractability_A_Guide_to_the_Theory_of_NP-Completeness","228057642_Probabilistic_checking_of_proofs_A_new_characterization_of_NP","227110773_On_the_complexity_of_approximating_the_independent_set_problem","222470961_Optimization_Approximation_and_Complexity_Classes","222463101_Zero_Knowledge_and_the_Chromatic_Number","221591773_878-approximation_algorithms_for_MAX_CUT_and_MAX_2SAT","221591101_The_Complexity_of_Theorem-Proving_Procedures","221590876_Trading_Group_Theory_for_Randomness","221590378_Testing_of_the_Long_Code_and_Hardness_for_Clique","221209287_Approximating_Maximum_Independent_Sets_by_Excluding_Subgraphs","220994687_On_the_Complexity_of_Approximating_the_Independent_Set_Problem","220695890_Computers_and_Intracdtability_A_Guide_to_the_Theory_of_NP-Completeness","220616711_Two-Prover_Protocols---Low_Error_at_Affordable_Rates","220616649_The_Knowledge_Complexity_of_Interactive_Proof_System","220573617_Approximation_Algorithms_for_Combinatorial_Problems","220432172_IP_PSPACE","3596358_Approximating_the_value_of_two_power_proof_systems_with_applications_to_MAX_2SAT_and_MAX_DICUT","3513508_Probabilistic_Checking_of_Proofs_A_New_Characterization_of_NP","3513499_Proof_verification_and_hardness_of_approximation_problems","2613692_On_the_Power_of_Multi-Prover_Interactive_Protocols","2574666_Linearity_Testing_in_Characteristic_Two","2503999_A_Parallel_Repetition_Theorem","2493479_Some_optimal_inapproximability_results","2485167_Improved_Non-Approximability_Results","2323065_A_Threshold_of_Ln_N_for_Approximating_Set_Cover","2264279_Efficient_Probabilistically_Checkable_Proofs_and_Applications_to_Approximation","2263641_On_Unapproximable_Versions_of_NP-Complete_Problems","2237681_Approximating_the_value_of_two_prover_proof_systems_with_applications_to_MAX_2SAT_and_MAX_DICUT"]}