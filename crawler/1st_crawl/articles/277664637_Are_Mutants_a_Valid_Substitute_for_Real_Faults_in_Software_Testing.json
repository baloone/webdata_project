{"id":"277664637_Are_Mutants_a_Valid_Substitute_for_Real_Faults_in_Software_Testing","abstract":"A good test suite is one that detects real faults. Because the set of faults in a program is usually unknowable, this definition is not useful to practitioners who are creating test suites, nor to researchers who are creating and evaluating tools that generate test suites. In place of real faults, testing research often uses mutants, which are artificial faults — each one a simple syntactic variation — that are systematically seeded throughout the program under test. Mutation analysis is appealing because large numbers of mutants can be automatically-generated and used to compensate for low quantities or the absence of known real faults. Unfortunately, there is little experimental evidence to support the use of mutants as a replacement for real faults. This paper investigates whether mutants are indeed a valid substitute for real faults, i.e., whether a test suite's ability to detect mutants is correlated with its ability to detect real faults that developers have fixed. Unlike prior studies, these investigations also explicitly consider the conflating effects of code coverage on the mutant detection rate. Our experiments used 357 real faults in 5 open-source applications that comprise a total of 321,000 lines of code. Furthermore, our experiments used both developer-written and automatically-generated test suites. The results show a statistically significant correlation between mutant detection and real fault detection, independently of code coverage. The results also give concrete suggestions on how to improve mutation analysis and reveal some inherent limitations.","authors":["Rene Just","Darioush Jalali","Laura Inozemtseva","Michael D Ernst"],"meta":["November 2014","DOI:10.1145/2635868.2635929","Conference: Symposium on the Foundations of Software Engineering (FSE)"],"references":["266659285_Defects4J_a_database_of_existing_faults_to_enable_controlled_testing_studies_for_Java_programs","266659273_Efficient_mutation_analysis_by_propagating_and_partitioning_infected_execution_states","266659085_The_major_mutation_framework_Efficient_and_scalable_mutation_analysis_for_Java","266656267_A_study_of_equivalent_and_stubborn_mutation_operators_using_human_analysis_of_equivalence","316985252_A_Study_of_Equivalent_and_Stubborn_Mutation_Operators_using_Human_Analysis_of_Equivalence","289400619_Mutation-driven_generation_of_unit_tests_and_oracles","271436939_DSD-Crasher","268237854_Software_error_analysis","266659277_Empirically_revisiting_the_test_independence_assumption","266656203_Coverage_is_not_strongly_correlated_with_test_suite_effectiveness"]}