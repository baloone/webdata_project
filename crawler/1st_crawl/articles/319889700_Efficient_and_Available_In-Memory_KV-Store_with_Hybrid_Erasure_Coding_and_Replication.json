{"id":"319889700_Efficient_and_Available_In-Memory_KV-Store_with_Hybrid_Erasure_Coding_and_Replication","abstract":"In-memory key/value store (KV-store) is a key building block for many systems like databases and large websites. Two key requirements for such systems are efficiency and availability, which demand a KV-store to continuously handle millions of requests per second. A common approach to availability is using replication, such as primary-backup (PBR), which, however, requires M+1 times memory to tolerate M failures. This renders scarce memory unable to handle useful user jobs.\nThis article makes the first case of building highly available in-memory KV-store by integrating erasure coding to achieve memory efficiency, while not notably degrading performance. A main challenge is that an in-memory KV-store has much scattered metadata. A single KV put may cause excessive coding operations and parity updates due to excessive small updates to metadata. Our approach, namely Cocytus, addresses this challenge by using a hybrid scheme that leverages PBR for small-sized and scattered data (e.g., metadata and key), while only applying erasure coding to relatively large data (e.g., value). To mitigate well-known issues like lengthy recovery of erasure coding, Cocytus uses an online recovery scheme by leveraging the replicated metadata information to continuously serve KV requests. To further demonstrate the usefulness of Cocytus, we have built a transaction layer by using Cocytus as a fast and reliable storage layer to store database records and transaction logs. We have integrated the design of Cocytus to Memcached and extend it to support in-memory transactions. Evaluation using YCSB with different KV configurations shows that Cocytus incurs low overhead for latency and throughput, can tolerate node failures with fast online recovery, while saving 33% to 46% memory compared to PBR when tolerating two failures. A further evaluation using the SmallBank OLTP benchmark shows that in-memory transactions can run atop Cocytus with high throughput, low latency, and low abort rate and recover fast from consecutive failures.","authors":["Haibo Chen","Heng Zhang","Mingkai Dong","Zhaoguo Wang"],"meta":["September 2017ACM Transactions on Storage 13(3):1-30","DOI:10.1145/3129900"],"references":["298102067_No_compromises","290297030_Fast_in-memory_transaction_processing_using_RDMA_and_HTM","289881173_Spanner","286662919_Replication-Based_Fault-Tolerance_for_Large-Scale_Graph_Processing","276465013_OLTP-Bench","262347913_Hekaton_SQL_server's_memory-optimized_OLTP_engine","254461663_Workload_analysis_of_a_large-scale_key-value_store","251380824_Jerasure_A_Library_in_CC_Facilitating_Erasure_Coding_for_Storage_Applications_Version_12","234131329_XORing_Elephants_Novel_Erasure_Codes_for_Big_Data","228705515_Paxos_replicated_state_machines_as_the_basis_of_a_high-performance_data_store","224994304_The_SAP_HANA_database_-_An_architecture_overview","220939050_NV-Heaps_Making_Persistent_Objects_Fast_and_Safe_with_Next-Generation_Non-Volatile_Memories","220910064_Hypervisor-based_Fault-tolerance","220910006_Separating_agreement_from_execution_for_byzantine_fault_tolerant_services","220909995_Fast_crash_recovery_in_RAMCloud","220909914_UpRight_cluster_services","220851686_Chain_Replication_for_Supporting_High_Throughput_and_Availability","318409952_Fast_in-memory_transaction_processing_using_RDMA_and_HTM","314271189_WiscKey_Separating_Keys_from_Values_in_SSD-Conscious_Storage","313736853_Scalable_performance_of_the_panasas_parallel_file_system","313136613_Oracle_timesten_An_in-memory_database_for_enterprise_applications","311556501_Lazy_means_smart_Reducing_repair_bandwidth_costs_in_erasure-coded_distributed_storage","308839265_Atlas_Baidu's_key-value_storage_system_for_cloud_data","301282085_Fast_and_general_distributed_transactions_using_RDMA_and_HTM","288492165_Lazy_Means_Smart","287001523_OLTP-bench_An_extensible_testbed_for_benchmarking_relational_databases","280571314_NV-Tree_Reducing_Consistency_Cost_for_NVM-based_Single_Level_Systems","277896757_Mojim_A_Reliable_and_Highly-Available_Non-Volatile_Memory_System","275575316_XORing_elephants","266659972_Using_RDMA_Efficiently_for_Key-Value_Services","266657190_Algorithmic_improvements_for_fast_concurrent_Cuckoo_hashing","266657107_Using_restricted_transactional_memory_to_build_a_scalable_in-memory_database","266656502_Fast_database_restarts_at_Facebook","262411304_Wimpy_nodes_with_10GbE_leveraging_one-sided_operations_in_soft-RDMA_to_boost_memcached","262389730_Serializable_Isolation_for_Snapshot_Databases","262366462_Using_one-sided_RDMA_reads_to_build_a_fast_CPU-efficient_key-value_store","262363395_Spanner_Google's_Globally_Distributed_Database","262362087_Gnothi_separating_data_and_metadata_for_efficient_and_available_storage_replication","262317728_Scaling_Memcache_at_Facebook","262310130_Erasure_coding_in_windows_azure_storage","262233395_Calvin_Fast_distributed_transactions_for_partitioned_database_systems","262214935_A_Bloat-Aware_Design_for_Big_Data_Applications","262204705_MemC3_compact_and_concurrent_MemCache_with_dumber_caching_and_smarter_hashing","260542287_Distributed_Storage_Codes_With_Repair-by-Transfer_and_Nonachievability_of_Interior_Points_on_the_Storage-Bandwidth_Tradeoff","259860916_Polynomial_Codes_Over_Certain_Finite_Fields","256327043_A_Solution_to_the_Network_Challenges_of_Data_Recovery_in_Erasure-coded_Distributed_Storage_Systems_A_Study_on_the_Facebook_Warehouse_Cluster","221353799_Consistent_and_Durable_Data_Structures_for_Non-Volatile_Byte-Addressable_Memory","221353746_Scalable_Performance_of_the_Panasas_Parallel_File_System","221214397_Serializable_Isolation_for_Snapshot_Databases","220831908_Benchmarking_cloud_serving_systems_with_YCSB","220439170_Hypervisor-Based_Fault_Tolerance","49459513_TPC-E_vs_TPC-C_characterizing_the_new_TPC-E_benchmark_via_an_IO_comparison_study","220432999_Zipfian_and_Lotkaian_continuous_concentration_theory","216824955_Distributed_Snapshots_Determining_Global_States_of_Distributed_Systems","209179779_Distributed_caching_with_Memcached"]}