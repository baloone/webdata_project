{"id":"300571615_Test-and-Set_in_Optimal_Space","abstract":"The test-and-set object is a fundamental synchronization primitive for shared memory systems. This paper addresses the number of registers (supporting atomic reads and writes) required to implement a one-shot test-and-set object in the standard asynchronous shared memory model with n processes. The best lower bound is log n - 1 [12,21] for obstruction-free and deadlock-free implementations, and recently a deterministic obstruction-free implementation using O(√ n) registers was presented [11].\nThis paper closes the gap between these existing upper and lower bounds by presenting a deterministic obstruction-free implementation of a one-shot test-and-set object from Θ(log n) registers of size Θ(log n) bits. Combining our obstruction-free algorithm with techniques from previous research [11,12], we also obtain a randomized wait-free test-and-set algorithm from Θ(log n) registers, with expected step-complexity Θ(log* n) against the oblivious adversary. The core tool in our algorithm is the implementation of a deterministic obstruction-free sifter object, using only 6 registers. If k processes access a sifter, then when they have terminated, at least one and at most ⌊(2k+1)/3⌋ processes return \"win\" and all others return \"lose\".","authors":["George Giakkoupis","Maryam Helmi","Lisa Higham","Philipp Woelfel"],"meta":["June 2015","DOI:10.1145/2746539.2746627","Conference: the Forty-Seventh Annual ACM"],"references":["225711833_Randomized_Two-Process_Wait-Free_Test-and-Set","221344237_Toward_a_Theory_of_Transactional_Contention_Managers","221343398_Optimal-Time_Adaptive_Strong_Renaming_with_Applications_to_Counting_Extended_Abstract","221234193_Obstruction-Free_Algorithms_Can_Be_Practically_Wait-Free","221233823_Fast_Randomized_Test-and-Set_and_Renaming","221233796_Sub-logarithmic_Test-and-Set_against_a_Weak_Adversary","221233720_Wait-free_Test-and-Set_Extended_Abstract","47842800_Randomized_Naming_Using_Wait-Free_Shared_Variables","4017166_Obstruction-Free_Synchronization_Double-Ended_Queues_as_an_Example","2648040_Wait-Free_Synchronization","1955735_On_the_Importance_of_Having_an_Identity_or_is_Consensus_really_Universal_Extended_Abstract","312944514_Fast_Randomized_Test-and-Set_and_Renaming","312880972_Optimal-Time_Adaptive_Strong_Renaming_with_Applications_to_Counting","312742396_Space-_and_Time-Efficient_Long-Lived_Test-And-Set_Objects","309456250_Wait-free_synchronization_ACM_Trans","285449594_An_Osqrt_n_Space_Bound_for_Obstruction-Free_Leader_Election","262365220_An_O1_RMRs_leader_election_algorithm","257285788_Bounds_on_Shared_Memory_for_Mutual_Exclusion","233415821_Tight_RMR_Lower_Bounds_for_Randomized_Mutual_Exclusion","233415819_On_the_Time_and_Space_Complexity_of_Randomized_Test-And-Set","221498415_The_Complexity_of_Renaming","221343715_Tight_Bounds_for_Shared_Memory_Symmetric_Mutual_Exclusion_Problems","221234107_Long-Lived_Fast_Waitfree_Renaming_with_Optimal_Name_Space_and_High_Throughput","220617578_Time_and_Space_Lower_Bounds_for_Nonblocking_Implementations","220404795_Efficient_Synchronization_on_Multiprocessors_with_Shared_Memory"]}