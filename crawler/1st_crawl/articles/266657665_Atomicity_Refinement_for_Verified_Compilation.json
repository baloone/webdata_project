{"id":"266657665_Atomicity_Refinement_for_Verified_Compilation","abstract":"We consider the verified compilation of high-level managed languages like Java or C# whose intermediate representations provide support for shared-memory synchronization and automatic memory management. In this environment, the interactions between application threads and the language runtime (e.g., the garbage collector) are regulated by compiler-injected code snippets. Example of snippets include allocation fast paths among others. In our TOPLAS paper we propose a refinement-based proof methodology that precisely relates concurrent code expressed at different abstraction levels, cognizant throughout of the relaxed memory semantics of the underlying processor. Our technique allows the compiler writer to reason compositionally about the atomicity of low-level concurrent code used to implement managed services. We illustrate our approach with examples taken from the verification of a concurrent garbage collector.","authors":["Suresh Jagannathan","Vincent Laporte","Gustavo Petri","David Pichardie"],"meta":["June 2014ACM SIGPLAN Notices 49(6)","DOI:10.1145/2666356.2594346"],"references":["265570794_The_CompCert_Memory_Model_Version_2","262203749_Checking_and_Enforcing_Robustness_against_TSO","261859777_CompCertTSO_A_Verified_Compiler_for_Relaxed-Memory_Concurrency","313550915_An_Axiomatic_Basis_of_Computer_Programming","279636664_Weak_ordering-A_new_definition","269158422_Weak_ordering--A_new_definition","262391123_Concurrent_Library_Correctness_on_the_TSO_Memory_Model","262274925_Partial_Orders_for_Efficient_Bounded_Model_Checking_of_Concurrent_Software","242637744_A_fully_abstract_semantics_of_a_shared_variable_parallel_language","239579778_Systems_programming_coping_with_parallelism"]}