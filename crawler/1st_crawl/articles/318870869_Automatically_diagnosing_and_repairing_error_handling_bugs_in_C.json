{"id":"318870869_Automatically_diagnosing_and_repairing_error_handling_bugs_in_C","abstract":"Correct error handling is essential for building reliable and secure systems. Unfortunately, low-level languages like C often do not support any error handling primitives and leave it up to the developers to create their own mechanisms for error propagation and handling. However, in practice, the developers often make mistakes while writing the repetitive and tedious error handling code and inadvertently introduce bugs. Such error handling bugs often have severe consequences undermining the security and reliability of the affected systems. Fixing these bugs is also tiringâthey are repetitive and cumbersome to implement. Therefore, it is crucial to develop tool supports for automatically detecting and fixing error handling bugs.\nTo understand the nature of error handling bugs that occur in widely used C programs, we conduct a comprehensive study of real world error handling bugs and their fixes. Leveraging the knowledge, we then design, implement, and evaluate ErrDoc, a tool that not only detects and characterizes different types of error handling bugs but also automatically fixes them. Our evaluation on five open-source projects shows that ErrDoc can detect error handling bugs with 100% to 84% precision and around 95% recall, and categorize them with 83% to 96% precision and above 90% recall. Thus, ErrDoc improves precision up to 5 percentage points, and recall up to 44 percentage points w.r.t. the state-of-the-art. We also demonstrate that ErrDoc can fix the bugs with high accuracy.","authors":["Yuchi Tian","Baishakhi Ray"],"meta":["August 2017","DOI:10.1145/3106237.3106300","Conference: the 2017 11th Joint Meeting"],"references":["306254977_Automatically_Detecting_Error_Handling_Bugs_Using_Error_Specifications","282155495_Directed_Incremental_Symbolic_Execution","260250447_Learning_Natural_Coding_Conventions","237054160_MintHint_Automated_Synthesis_of_Repair_Hints","221560535_Y_PR-Miner_Automatically_extracting_implicit_programming_rules_and_detecting_violations_in_large_software_codes","221246529_Finding_Error_Handling_Bugs_in_OpenSSL_Using_Coccinelle","220883310_Iterative_Mining_of_Resource-Releasing_Specifications","2407113_Designing_Robust_Java_Programs_with_Exceptions","2284886_Analyzing_Exception_Flow_in_Java_Programs","311474159_Systematic_editing_generating_program_transformations_from_an_example","310824346_APEx_automated_inference_of_error_specifications_for_C_APIs","286192471_Flint","281663872_Flint_Fixing_Linearizability_Violations","262328665_Modular_and_Verified_Automatic_Program_Repair","261453419_Hector_Detecting_Resource-Release_Omission_Faults_in_error-handling_code_for_systems_software","261230128_Automatic_patch_generation_learned_from_human-written_patches","254041670_A_systematic_study_of_automated_program_repair_Fixing_55_out_of_105_bugs_for_8_each","221560308_Sydit_Creating_and_applying_a_program_transformation_from_an_example","221353806_EIO_Error_Handling_is_Occasionally_Correct","220752213_Directed_Incremental_Symbolic_Execution","220751975_Error_Propagation_Analysis_for_File_Systems","220423796_Npath_A_Measure_of_Execution_Path_Complexity_and_Its_Applications","220404460_Exceptional_situations_and_program_reliability","2616133_Finding_and_Preventing_Run-Time_Error_Handling_Mistakes","2573732_Bugs_as_Deviant_Behavior_A_General_Approach_to_Inferring_Errors_in_Systems_Code"]}