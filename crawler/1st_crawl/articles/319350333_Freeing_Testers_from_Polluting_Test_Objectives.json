{"id":"319350333_Freeing_Testers_from_Polluting_Test_Objectives","abstract":"Testing is the primary approach for detecting software defects. A major challenge faced by testers lies in crafting efficient test suites, able to detect a maximum number of bugs with manageable effort. To do so, they rely on coverage criteria, which define some precise test objectives to be covered. However, many common criteria specify a significant number of objectives that occur to be infeasible or redundant in practice, like covering dead code or semantically equal mutants. Such objectives are well-known to be harmful to the design of test suites, impacting both the efficiency and precision of testers' effort. This work introduces a sound and scalable formal technique able to prune out a significant part of the infeasible and redundant objectives produced by a large panel of white-box criteria. In a nutshell, we reduce this challenging problem to proving the validity of logical assertions in the code under test. This technique is implemented in a tool that relies on weakest-precondition calculus and SMT solving for proving the assertions. The tool is built on top of the Frama-C verification platform, which we carefully tune for our specific scalability needs. The experiments reveal that the tool can prune out up to 27% of test objectives in a program and scale to applications of 200K lines of code.","authors":["Michaël Marcozzi","Sébastien Bardin","Nikolai Kosmatov","Mike Papadakis"],"meta":["August 2017","Project: Ltest: a Criterion-Independant White-Box Testing Toolbox"],"references":["312529912_Generic_and_Effective_Specification_of_Structural_Test_Objectives","318734383_An_Axiomatic_Basis_for_Computer_Programming","315466480_Detecting_Trivial_Mutant_Equivalences_via_Compiler_Optimisations","313550915_An_Axiomatic_Basis_of_Computer_Programming","312530127_Taming_Coverage_Criteria_Heterogeneity_with_LTest","309611828_Analyzing_the_validity_of_selective_mutation_with_dominator_mutants","308862503_Combining_Symbolic_Execution_and_Model_Checking_for_Data_Flow_Testing","305870243_Are_We_There_Yet_How_Redundant_and_Equivalent_Mutants_Affect_Determination_of_Test_Completeness","305026954_Threats_to_the_validity_of_mutation-based_test_assessment","301888889_Mutant_Reduction_Based_on_Dominance_Relation_for_Weak_Mutation_Testing","282895362_Guidelines_for_Coverage-Based_Comparisons_of_Non-Adequate_Test_Suites","282378950_Sound_and_Quasi-Complete_Detection_of_Infeasible_Test_Requirements","281584658_Trivial_Compiler_Equivalence_A_Large_Scale_Empirical_Study_of_a_Simple_Fast_and_Effective_Equivalent_Mutant_Detection_Technique","293814532_Static_analysis_of_mutant_subsumption","283575085_Bidirectional_Symbolic_Analysis_for_Effective_Branch_Testing"]}