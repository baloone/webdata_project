{"id":"266656596_Overlap_interval_partition_join","abstract":"Each tuple in a valid-time relation includes an interval attribute T that represents the tuple's valid time. The overlap join between two valid-time relations determines all pairs of tuples with overlapping intervals. Although overlap joins are common, existing partitioning and indexing schemes are inefficient if the data includes long-lived tuples or if intervals intersect partition boundaries.\nWe propose Overlap Interval Partitioning (OIP), a new partitioning approach for data with an interval. OIP divides the time range of a relation into k base granules and defines overlapping partitions for sequences of contiguous granules. OIP is the first partitioning method for interval data that gives a constant clustering guarantee: the difference in duration between the interval of a tuple and the interval of its partition is independent of the duration of the tuple's interval. We offer a detailed analysis of the average false hit ratio and the average number of partition accesses for queries with overlap predicates, and we prove that the average false hit ratio is independent of the number of short- and long-lived tuples. To compute the overlap join, we propose the Overlap Interval Partition Join (OIPJoin), which uses OIP to partition the input relations on-the-fly. Only the tuples from overlapping partitions have to be joined to compute the result. We analytically derive the optimal number of granules, k, for partitioning the two input relations, from the size of the data, the cost of CPU operations, and the cost of main memory or disk IOs. Our experiments confirm the analytical results and show that the OIPJoin outperforms state-of-the-art techniques for the overlap join.","authors":["Anton Dignös","Michael H. Böhlen","Johann Gamper"],"meta":["June 2014","DOI:10.1145/2588555.2612175","Conference: Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data"],"references":["225570919_Join_Operations_in_Temporal_Databases","221309807_Managing_Intervals_Efficiently_in_Object-Relational_Databases","221214844_Joining_Interval_Data_in_Relational_Databases","220690791_Operating_system_concepts_7_ed","220197855_Quad_Trees_A_Data_Structure_for_Retrieval_on_Composite_Keys","2458422_Spatial_Hash-Joins","2418547_Efficient_Evaluation_of_the_Valid-Time_Natural_Join","313708771_The_R-tree_An_efficient_and_robust_access_method_for_points_and_rectangles","300257891_More_Geometric_Data_Structures","275501784_Distance_Regular_Graphs","262320998_Indexing_methods_for_moving_object_databases_Games_and_other_applications","262155348_TOUCH_In-memory_spatial_join_by_hierarchical_data-oriented_partitioning","261349842_Query_time_scaling_of_attribute_values_in_interval_timestamped_databases","254006789_Temporal_alignment","239536213_Foundations_Of_Multidimensional_And_Metric_Data_Structures","238680582_University_information_system_uis_dataset","233932988_Distance-Regular_Graphs","222912636_The_Snapshot_Index_An_IO-Optimal_access_method_for_timeslice_queries","221310038_On_Spatially_Partitioned_Temporal_Join","221214841_A_revised_r-tree_in_comparison_with_related_index_structures","200040509_Operating_System_Concepts","33030362_The_R-Tree_An_Efficient_and_Robust_Access_Method_for_Points_and_Rectangles","2774619_Size_Separation_Spatial_Join"]}