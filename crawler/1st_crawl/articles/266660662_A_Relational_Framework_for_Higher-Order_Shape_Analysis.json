{"id":"266660662_A_Relational_Framework_for_Higher-Order_Shape_Analysis","abstract":"We propose the integration of a relational specification framework within a dependent type system capable of verifying complex invariants over the shapes of algebraic datatypes. Our approach is based on the observation that structural properties of such datatypes can often be naturally expressed as inductively-defined relations over the recursive structure evident in their definitions. By interpreting constructor applications (abstractly) in a relational domain, we can define expressive relational abstractions for a variety of complex data structures, whose structural and shape invariants can be automatically verified. Our specification language also allows for definitions of parametricrelations for polymorphic data types that enable highly composable specifications and naturally generalizes to higher-order polymorphic functions.\nWe describe an algorithm that translates relational specifications into a decidable fragment of first-order logic that can be efficiently discharged by an SMT solver. We have implemented these ideas in a type checker called CATALYST that is incorporated within the MLton SML compiler. Experimental results and case studies indicate that our verification strategy is both practical and effective.","authors":["Gowtham Kaki","Suresh Jagannathan"],"meta":["August 2014ACM SIGPLAN Notices 49(9)","DOI:10.1145/2628136.2628159"],"references":["262312016_Abstract_Refinement_Types","248478347_Reading_Writing_and_Relations_Towards_Extensional_Semantics_for_Effect_Analyses","225574944_A_Relational_Approach_to_Interprocedural_Shape_Analysis","225164165_Step-Indexed_Syntactic_Logical_Relations_for_Recursive_and_Quantified_Types","221336361_Relational_semantics_for_effect-based_program_transformations","221241216_Secure_Distributed_Programming_with_Value-Dependent_Types","221241120_Binders_Unbound","220997083_Self-certification_Bootstrapping_certified_typecheckers_in_F_with_Coq","220727387_Relational_Reasoning_in_a_Nominal_Semantics_for_Storage","50235669_Logical_Step-Indexed_Logical_Relations","268484595_Self-certification","262289860_Hasochism_The_Pleasure_and_Pain_of_Dependently_Typed_Haskell_Programming","259423786_Generic_top-down_discrimination_for_sorting_and_partitioning_in_linear_time","228792084_Deciding_effectively_propositional_logic_with_equality","226489235_The_Locally_Nameless_Representation","221551063_Shape_Analysis_in_the_Absence_of_Pointers_and_Structure","220752217_Liquid_types","220752199_Type-based_Data_Structure_Verification","220404534_A_relational_approach_to_interprocedural_shape_analysis","213885504_Guarded_recursive_dataype_constructors","41939518_On_Decision_Procedures_for_Algebraic_Data_Types_with_Abstractions","36013217_Purely_Functional_Data_Structures","2513409_Local_Type_Inference","2384852_Faking_It_Simulating_Dependent_Types_in_Haskell"]}