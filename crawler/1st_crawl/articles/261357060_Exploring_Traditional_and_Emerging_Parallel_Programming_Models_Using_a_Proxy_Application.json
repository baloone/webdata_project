{"id":"261357060_Exploring_Traditional_and_Emerging_Parallel_Programming_Models_Using_a_Proxy_Application","abstract":"Parallel machines are becoming more complex with increasing core counts and more heterogeneous architectures. However, the commonly used parallel programming models, C/C++ with MPI and/or OpenMP, make it difficult to write source code that is easily tuned for many targets. Newer language approaches attempt to ease this burden by providing optimization features such as automatic load balancing, overlap of computation and communication, message-driven execution, and implicit data layout optimizations. In this paper, we compare several implementations of LULESH, a proxy application for shock hydrodynamics, to determine strengths and weaknesses of different programming models for parallel computation. We focus on four traditional (OpenMP, MPI, MPI+OpenMP, CUDA) and four emerging (Chapel, Charm++, Liszt, Loci) programming models. In evaluating these models, we focus on programmer productivity, performance and ease of applying optimizations.","authors":["Ian Karlin","Abhinav Bhatele","Jeff Keasler","Bradford L. Chamberlain"],"meta":["May 2013","DOI:10.1109/IPDPS.2013.115","Conference: Parallel & Distributed Processing (IPDPS), 2013 IEEE 27th International Symposium on"],"references":["277825629_A_Comparison_of_some_recent_Task-based_Parallel_Programming_Models","276951339_Domain-Specific_Languages","258883167_Memory_and_Parallelism_Exploration_using_the_LULESH_Proxy_Application","313106625_SEQUEL_A_structured_english_query_language","294246745_Performance_portable_C","279401769_CHARM","272356916_Nvidia_Cuda_C_Programming_Guide","258139318_Parallel_Programmability_and_the_Chapel_Language","256293893_Experimental_testing_and_thermal_analysis_of_ball_bearings","245213642_3-D_numerical_and_experimental_analysis_of_a_built-in_motorized_high-speed_spindle_with_helical_water_cooling_channel"]}