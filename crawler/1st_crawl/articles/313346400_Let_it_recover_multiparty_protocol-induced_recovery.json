{"id":"313346400_Let_it_recover_multiparty_protocol-induced_recovery","abstract":"Fault-tolerant communication systems rely on recovery strategies which are often error-prone (e.g. a programmer manually specifies recovery strategies) or inefficient (e.g. the whole system is restarted from the beginning). This paper proposes a static analysis based on multiparty session types that can efficiently compute a safe global state from which a system of interacting processes should be recovered. We statically analyse the communication flow of a program, given as a multiparty protocol, to extract the causal dependencies between processes and to localise failures. We formalise our recovery algorithm and prove its safety. A recovered communication system is free from deadlocks, orphan messages and reception errors. Our recovery algorithm incurs less communication cost (only affected processes are notified) and overall execution time (only required states are repeated). On top of our analysis, we design and implement a runtime framework in Erlang where failed processes and their dependencies are soundly restarted from a computed safe state. We evaluate our recovery framework on message-passing benchmarks and a use case for crawling webpages. The experimental results indicate our framework outperforms a built-in static recovery strategy in Erlang when a part of the protocol can be safely recovered.","authors":["Rumyana Neykova","Nobuko Yoshida"],"meta":["February 2017","DOI:10.1145/3033019.3033031","Conference: the 26th International Conference"],"references":["306043658_An_Erlang_Implementation_of_Multiparty_Session_Actors","304033322_Parallel_Monitors_for_Self-adaptive_Sessions","263126916_Session_Types_for_Broadcasting","262727145_ELarva_A_Monitoring_tool_for_Erlang","259220308_Session_Types_with_Runtime_Adaptation_Overview_and_Examples","220997896_Multiparty_Asynchonous_Session_Types","220700579_Structured_Interactional_Exceptions_in_Session_Types","311490157_Static_Deadlock_Detection_for_Concurrent_Go_by_Global_Session_Graph_Synthesis","309092166_Hybrid_Session_Verification_Through_Endpoint_API_Generation","308321197_Multiparty_Session_Actors","304702744_Typechecking_Protocols_with_Mungo_and_StMungo","304425747_Global_Escape_in_Multiparty_Sessions","303789186_Multiparty_asynchronous_session_types","303482010_A_Type_Theory_for_Robust_Failure_Handling_in_Distributed_Systems","290106149_Dynamic_Software_Update_for_Message_Passing_Programs","285187747_Savina_-_An_Actor_Benchmark_Suite_Enabling_Empirical_Evaluation_of_Actor_Libraries","284787633_Protocols_by_Default_Safe_MPI_Code_Generation_based_on_Session_Types","279423273_Analysing_Fault_Tolerance_for_Erlang_Applications","278382311_Practical_interruptible_conversations_Distributed_Dynamic_Verification_with_Session_Types_and_Python","276464822_From_Communicating_Machines_to_Graphical_Choreographies","268079901_Disciplined_structured_communications_with_disciplined_runtime_adaptation","267075972_Multiparty_Session_Types_Meet_Communicating_Automata","266661399_Typecasting_actors_from_Akka_to_TAkka","263126917_Multiparty_Session_Actors","262410813_Nested_Protocols_in_Session_Types","236124497_Multiparty_Compatibility_in_Communicating_Automata_Characterisation_and_Synthesis_of_Global_Session_Types","230775307_Parameterised_Multiparty_Session_Types","221211413_Automatic_assessment_of_failure_recovery_in_Erlang_applications","220430671_On_Communicating_Finite-State_Machines","220248800_Verification_of_programs_with_half-duplex_communication"]}