{"id":"261485947_Eternal_War_in_Memory","abstract":"Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program's behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently deployed protections can be defeated. This paper sheds light on the primary reasons for this by describing attacks that succeed on today's systems. We systematize the current knowledge about various protection techniques by setting up a general model for memory corruption attacks. Using this model we show what policies can stop which attacks. The model identifies weaknesses of currently deployed techniques, as well as other proposed protections enforcing stricter policies. We analyze the reasons why protection mechanisms implementing stricter polices are not deployed. To achieve wide adoption, protection mechanisms must support a multitude of features and must satisfy a host of requirements. Especially important is performance, as experience shows that only solutions whose overhead is in reasonable bounds get deployed. A comparison of different enforceable policies helps designers of new protection mechanisms in finding the balance between effectiveness (security) and efficiency. We identify some open research problems, and provide suggestions on improving the adoption of newer techniques.","authors":["Laszlo Szekeres","Mathias Payer","Tao Wei","Dawn Song"],"meta":["May 2013","DOI:10.1109/SP.2013.13","Conference: Security and Privacy (SP), 2013 IEEE Symposium on"],"references":["305293722_SoftBound_Highly_Compatible_and_Complete_Spatial_Memory_Safety_for_C","278714088_Valgrind_A_Program_Supervision_Framework","262274235_Binary_stirring_Self-randomizing_instruction_addresses_of_legacy_x86_binary_code","261310316_Just-In-Time_Code_Reuse_On_the_Effectiveness_of_Fine-Grained_Address_Space_Layout_Randomization","254044441_ILR_Where'd_my_gadgets_go","241633703_Smashing_the_Gadgets_Hindering_Return-Oriented_Programming_Using_In-place_Code_Randomization","236278779_Memory_Errors_The_Past_the_Present_and_the_Future","236278770_Body_Armor_for_Binaries_preventing_buffer_overflows_without_recompilation","234803818_Pointguard_TM_protecting_pointers_from_buffer_overflow_vulnerabilities","234790883_Non-control-data_attacks_are_realistic_threats","234784207_StackGuard_Automatic_adaptive_detection_and_prevention_of_buffer-overflow_attacks","228395603_Interpreter_Exploitation","226647311_Low-Level_Software_Security_by_Example","221609952_PAriCheck_An_efficient_pointer_arithmetic_checker_for_C_programs","221609365_Secure_dynamic_code_generation_against_spraying","221609042_ROPdefender_A_detection_tool_to_defend_against_return-oriented_programming_attacks","221608984_Return-Oriented_Programming_without_Returns","221560307_Protecting_C_programs_from_attacks_via_invalid_pointer_dereferences","221427518_Minemu_The_World's_Fastest_Taint_Tracker","221260561_Baggy_Bounds_Checking_An_Efficient_and_Backwards-Compatible_Defense_against_Out-of-Bounds_Errors","221260465_Cling_A_Memory_Allocator_to_Mitigate_Dangling_Pointers","221046496_Address_Space_Layout_Permutation_ASLP_Towards_Fine-Grained_Randomization_of_Commodity_Software","221046284_G-Free_Defeating_Return-Oriented_Programming_through_Gadget-less_Binaries","221032834_CETS_Compiler_enforced_temporal_safety_for_C","220970641_Breaking_the_memory_secrecy_assumption","312998514_Enforceable_security_policies","310404307_Securing_software_by_enforcing_data-flow_integrity","310404046_Baggy_bounds_checking_An_efficient_and_backwards-compatible_defense_against_out-of-bounds_errors","309900313_Efficient_software-based_fault_isolation","302568185_Data_Space_Randomization_DSR","280292422_Pin","278693342_CCured","267407038_kGuard_Lightweight_Kernel_Protection_against_Return-to-user_Attacks","262425522_AddressSanitizer_a_fast_address_sanity_checker","261310315_Practical_Control_Flow_Integrity_and_Randomization_for_Binary_Executables","254005135_Lightweight_bounds_checking","254004806_Runtime_Countermeasures_for_Code_Injection_Attacks_Against_C_and_C_Programs","248591806_Bypassing_PaX_ASLR_protection","243773181_Smashing_the_stack_for_fun_and_prot","242423464_Mitigating_Buffer_Overflows_by_Operating_System_Randomization","238758464_Protecting_from_stack_smashing_attacks","238513704_Return-Oriented_Programming_Systems_Languages_and_Applications","228848687_Q_Exploit_Hardening_Made_Easy","221609721_On_the_effectiveness_of_address-space_randomization","221609565_Countering_code-injection_attacks_with_instruction-set_randomization","221609557_Control-flow_integrity","221609055_Jump-oriented_programming_a_new_class_of_code-reuse_attack","221554273_Backwards-compatible_array_bounds_checking_for_C_with_very_low_overhead","221427626_On_the_Expressiveness_of_Return-into-libc_Attacks","221137826_Fine-grained_user-space_security_through_virtualization","220880915_Cyclone_A_safe_dialect_of_C","220752432_SoftBound_Highly_Compatible_and_Complete_Spatial_Memory_Safety_for_C","220752268_9_8_Pin_Building_Customized_Program_Analysis_Tools_with_Dynamic_Instrumentation","220851820_Securing_Software_by_Enforcing_Data-flow_Integrity","220851727_XFI_Software_Guards_for_System_Address_Spaces"]}