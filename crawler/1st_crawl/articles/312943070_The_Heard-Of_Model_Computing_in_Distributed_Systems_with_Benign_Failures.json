{"id":"312943070_The_Heard-Of_Model_Computing_in_Distributed_Systems_with_Benign_Failures","abstract":"html> Problems in fault-tolerant distributed computing have been studied in a variety of models. These models are structured around two central ideas: \nDegree of synchrony and failure model are two independent parameters that determine a particular type of system. \nThe notion of faulty component is helpful and even necessary for the analysis of distributed computations when failures occur. \n\nIn this work, we question these two basic principles of fault-tolerant distributed computing, and show that it is both possible and worthy to renounce them in the context of benign failures: we present a computational model, suitable for systems with benign failures, which is based only on the notion of transmission failure . \n\nIn this model, computations evolve in rounds, and messages missed at a round are lost. Only information transmission is represented: for each round r and each process p, our model provides the set of processes that p ``hears of'' at round r ( heard-of set ) namely the processes from which p receives some message at round r. The features of a specific system are thus captured as a whole, just by a predicate over the collection of heard-of sets. We show that our model handles benign failures, be they static or dynamic, permanent or transient, in a unified framework. \n\nUsing this new approach, we are able to give shorter and simpler proofs of important results (non-solvability, lower bounds). In particular, we prove that in general, Consensus cannot be solved without an implicit and permanent consensus on heard-of sets. We also examine Consensus algorithms in our model. In light of this specific agreement problem, we show how our approach allows us to devise new interesting solutions. \n</html","authors":["Bernadette Charron-Bost","AndrÃ© Schiper"],"meta":["January 2007"],"references":["290452037_Consensus_in_One_Communication_Step","221344302_Another_Advantage_of_Free_Choice_Completely_Asynchronous_Agreement_Protocols_Extended_Abstract","221343514_Round-by-Round_Fault_Detectors_Unifying_Synchrony_and_Asynchrony_Extended_Abstract","221246578_Solving_Agreement_Problems_with_Weak_Ordering_Oracles","220618342_A_Layered_Analysis_of_Consensus","220616485_Authenticated_Algorithms_for_Byzantine_Agreement","220567061_How_Processes_Learn","220432431_Early_Stopping_in_Byzantine_Agreement","220268431_Polynomial_Algorithms_for_Multiple_Processor_Agreement","37462679_Tolerating_Corrupted_Communication","4354974_On_the_minimal_synchronism_needed_for_distributed_consensus","2472055_Unifying_Synchronous_and_Asynchronous_Message-Passing_Models","280707327_The_weakest_failure_detector_for_solving_consensus","247385682_Reliable_broadcast_in_synchronous_and_asynchronous_environment","239534748_On_the_minimal_synchronization_needed_for_distributed_consensus","238745174_Unreliable_failure_detectors_for_asynchronous_systems","238313014_Round-by-round_fault_detector-unifying_synchrony_and_asynchrony","234831006_Reaching_Agreement_in_the_Presence_of_Faults","225110909_Time_is_not_a_healer","223201011_Automatically_increasing_the_fault-tolerance_of_distributed_algorithms","222460125_The_Byzantine_General_Strike_Again","221933011_Distributed_Algorithms","221233737_Reliable_Broadcast_in_Synchronous_and_Asynchronous_Environments_Preliminary_Version","221233089_Majority_and_Unanimity_in_Synchronous_Networks_with_Ubiquitous_Dynamic_Faults","220406761_A_Combinatorial_Characterization_of_the_Distributed_1-Solvable_Tasks","220131298_Francez_N_Decomposition_of_Distributed_Programs_into_Communication-Closed_Layers_Sci_Comput_Program_23_155-173","220111356_Extended_Impossibility_Results_for_Asynchronous_Complete_Networks","200031719_Impossibility_of_Distributed_Consensus_with_One_Faulty_Process","4354946_Randomized_Byzantine_generals","3908958_How_to_model_link_failures_A_perception-based_fault_model","2881859_Solving_Agreement_Problems_with_Weak","2626811_The_Part-Time_Parliament","2567049_Consensus_in_the_Presence_of_Partial_Synchrony"]}