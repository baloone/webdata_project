{"id":"344131954_Synthesizing_software_verifiers_from_proof_rules","abstract":"Automatically generated tools can significantly improve programmer productivity. For example, parsers and dataflow analyzers can be automatically generated from declarative specifications in the form of grammars, which tremendously simplifies the task of implementing a compiler. In this paper, we present a method for the automatic synthesis of software verification tools. Our synthesis procedure takes as input a description of the employed proof rule, e.g., program safety checking via inductive invariants, and produces a tool that automatically discovers the auxiliary assertions required by the proof rule, e.g., inductive loop invariants and procedure summaries. We rely on a (standard) representation of proof rules using recursive equations over the auxiliary assertions. The discovery of auxiliary assertions, i.e., solving the equations, is based on an iterative process that extrapolates solutions obtained for finitary unrollings of equations. We show how our method synthesizes automatic safety and liveness verifiers for programs with procedures, multi-threaded programs, and functional programs. Our experimental comparison of the resulting verifiers with existing state-of-the-art verification tools confirms the practicality of the approach.","authors":["Sergey Grebenshchikov","Nuno P. Lopes","Corneliu Popeea","Andrey Rybalchenko"],"meta":["August 2012ACM SIGPLAN Notices 47(6):405-416","DOI:10.1145/2345156.2254112"],"references":["234800126_Tentative_Steps_Toward_a_Development_Method_for_Interfering_Programs","226755122_The_MathSAT_4SMT_Solver","225353143_P_F-SOFT_Software_verification_platform","221403538_Linear_Ranking_with_Reachability","221336350_Dependent_type_inference_with_interpolants","220752331_Effective_static_race_detection_for_Java","220752113_Analyzing_Recursive_Programs_using_a_Fixed-point_Calculus","200034054_Context-sensitive_program_analysis_as_database_queries","2925210_Cloning-Based_Context-Sensitive_Pointer_Alias_Analysis_Using_Binary_Decision_Diagrams","268014351_Lecture_Notes_in_Computer_Science","266169753_Compositional_Termination_Proofs_for_Multi-Threaded_Programs","256651264_Numerical_Recipes_The_art_of_scientific_computing","255566670_Lecture_Notes_in_Computer_Science","221551051_A_Complete_Method_for_the_Synthesis_of_Linear_Ranking_Functions","221477273_Banshee_A_Scalable_Constraint-Based_Analysis_Toolkit","221403002_Lazy_Abstraction_with_Interpolants","221323258_Solving_Recursion-Free_Horn_Clauses_over_LIUIF","220997861_The_SLAM_project_Debugging_system_software_via_static_analysis","220997840_Precise_Interprocedural_Dataflow_Analysis_via_Graph_Reachability","220851944_An_Interpolating_Theorem_Prover","220691069_Temporal_Verification_of_Reactive_Systems_Safety","220673726_Summarization_for_termination_No_return","220673620_Generating_Model_Checkers_from_Algebraic_Specifications","220643299_PAG_-_An_Efficient_Program_Analyzer_Generator","220197726_An_Axiomatic_Proof_Technique_for_Parallel_Programs_I","220131195_Introduction_to_Set_Constraint-Based_Program_Analysis","47861725_Termination_Proofs_for_Systems_Code","2876792_Abstractions_from_Proofs"]}