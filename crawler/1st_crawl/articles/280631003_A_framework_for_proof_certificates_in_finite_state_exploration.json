{"id":"280631003_A_framework_for_proof_certificates_in_finite_state_exploration","abstract":"Model checkers use automated state exploration in order to prove various\nproperties such as reachability, non-reachability, and bisimulation over state\ntransition systems. While model checkers have proved valuable for locating\nerrors in computer models and specifications, they can also be used to prove\nproperties that might be consumed by other computational logic systems, such as\ntheorem provers. In such a situation, a prover must be able to trust that the\nmodel checker is correct. Instead of attempting to prove the correctness of a\nmodel checker, we ask that it outputs its \"proof evidence\" as a formally\ndefined document--a proof certificate--and that this document is checked by a\ntrusted proof checker. We describe a framework for defining and checking proof\ncertificates for a range of model checking problems. The core of this framework\nis a (focused) proof system that is augmented with premises that involve \"clerk\nand expert\" predicates. This framework is designed so that soundness can be\nguaranteed independently of any concerns for the correctness of the clerk and\nexpert specifications. To illustrate the flexibility of this framework, we\ndefine and formally check proof certificates for reachability and\nnon-reachability in graphs, as well as bisimulation and non-bisimulation for\nlabeled transition systems. Finally, we describe briefly a reference checker\nthat we have implemented for this framework.","authors":["Quentin Heath","Dale Miller"],"meta":["July 2015","DOI:10.4204/EPTCS.186.4","SourcearXiv"],"references":["280789334_Abella_A_System_for_Reasoning_about_Relational_Specifications","262157282_Foundational_Proof_Certificates_in_First-Order_Logic","246839477_Mixing_Finite_Success_and_Finite_Failure_in_an_Automated_Prover","269009462_Programming_with_Higher-Order_Logic","265371850_Enhancements_of_the_bisimulation_proof_method","224001269_Communication_and_Concurrency","222686498_Nominal_Abstraction","222480860_Uniform_Proofs_as_a_Foundation_for_Logic_Programming","222297681_Proof_and_Refutation_in_MALL_as_a_game","222181428_Cut-elimination_for_a_logic_with_definitions_and_induction"]}