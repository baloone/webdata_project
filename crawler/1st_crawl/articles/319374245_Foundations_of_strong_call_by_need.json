{"id":"319374245_Foundations_of_strong_call_by_need","abstract":"We present a call-by-need strategy for computing strong normal forms of open terms (reduction is admitted inside the body of abstractions and substitutions, and the terms may contain free variables), which guarantees that arguments are only evaluated when needed and at most once. The strategy is shown to be complete with respect to Î²-reduction to strong normal form. The proof of completeness relies on two key tools: (1) the definition of a strong call-by-need calculus where reduction may be performed inside any context, and (2) the use of non-idempotent intersection types. More precisely, terms admitting a Î²-normal form in pure lambda calculus are typable, typability implies (weak) normalisation in the strong call-by-need calculus, and weak normalisation in the strong call-by-need calculus implies normalisation in the strong call-by-need strategy. Our (strong) call-by-need strategy is also shown to be conservative over the standard (weak) call-by-need.","authors":["Thibaut Balabonski","Pablo Barenbaum","Eduardo Bonelli","Delia Kesner"],"meta":["August 2017Proceedings of the ACM on Programming Languages 1(ICFP):1-29","DOI:10.1145/3110264","Project: Call-by-need"],"references":["285917425_Some_notes_on_lambda-reduction","281487133_A_Strong_Distillery","262322909_Complexity_of_Strongly_Normalising_l-Terms_via_Non-idempotent_Intersection_Types","257409975_Non-idempotent_intersection_types_and_strong_normalisation","242529440_Optimal_reductions_in_the_lambda_calculus","228107019_Functional_Characters_of_Solvable_Terms","221241347_A_Compiled_Implementation_of_Strong_Reduction","220368224_Local_Bigraphs_and_Confluence_Two_Conjectures","45853428_Execution_Time_of_lambda-Terms_via_Denotational_Semantics_and_Intersection_Types","2644272_The_Call-by-Need_Lambda_Calculus_Unabridged","2639371_A_Natural_Semantics_for_Lazy_Evaluation","2597124_A_Call-By-Need_Lambda_Calculus","320144394_Non-idempotent_intersection_types_for_the_Lambda-Calculus","308099754_Reasoning_About_Call-by-need_by_Means_of_Types","307738053_A_Resource_Aware_Computational_Interpretation_for_Herbelin's_Syntax","307564236_Open_Call-by-Value","289587495_Leftmost-Outermost_Beta_Reduction_is_Invariant_Indeed","281049946_An_abstract_factorization_theorem_for_explicit_substitutions","278618932_The_structural_lambda-calculus","267177954_Quantitative_Types_for_the_Linear_Substitution_Calculus","266660564_Distilling_Abstract_Machines","262393532_Deriving_the_full-reducing_Krivine_machine_from_the_small-step_operational_semantics_of_normal_order","262368056_Weak_Optimality_and_the_Meaning_of_Sharing","262270408_A_synthetic_operational_account_of_call-by-need_evaluation","253646227_Bounding_normalization_time_through_intersection_types","239564871_The_call-byneed_lambda_calculus","235624822_Semantics_and_Pragmatics_of_the_Lambda-Calculus","225105485_Full_Reduction_at_Full_Throttle","222440185_Complete_restrictions_of_the_intersection_type_discipline","222297264_Principality_and_type_inference_for_intersection_types_using_expansion_variables","221652967_Bohm_Trees_Krivine's_Machine_and_the_Taylor_Expansion_of_Lambda-Terms","221252265_An_Abstract_Machine_for_Lambda-Terms_Normalization","220997764_A_Lazy_Evaluator","220997608_An_Algorithm_for_Optimal_Lambda_Calculus_Reduction","220832277_Discovering_Needed_Reductions_Using_Type_Theory","220607072_Strongly_reducing_variants_of_the_Krivine_abstract_machine","220388148_A_Linearization_of_the_Lambda-Calculus_and_Consequences","220315927_Intentional_Interpretations_of_Functionals_of_Finite_Type_I","213879686_The_Implementation_of_Functional_Programming_Languages","51990339_The_Call-by-Need_Lambda_Calculus_Revisited","50296963_Lambda-calculus_Types_and_Models","45851716_A_Theory_of_Explicit_Substitutions_with_Safe_and_Full_Composition","38355924_An_extension_of_basic_functionality_theory_for_L-calculus"]}