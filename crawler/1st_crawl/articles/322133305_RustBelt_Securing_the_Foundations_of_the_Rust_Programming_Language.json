{"id":"322133305_RustBelt_Securing_the_Foundations_of_the_Rust_Programming_Language","abstract":"Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.","authors":["Ralf Jung","Jacques-Henri Jourdan","Robbert Krebbers","Derek Dreyer"],"meta":["December 2017Proceedings of the ACM on Programming Languages 2(POPL):1-34","DOI:10.1145/3158154"],"references":["329122832_Iris_from_the_ground_up_A_modular_foundation_for_higher-order_concurrent_separation_logic","265570794_The_CompCert_Memory_Model_Version_2","261554680_Impredicative_Concurrent_Abstract_Predicates","259901424_Communicating_State_Transition_Systems_for_Fine-Grained_Concurrent_Resources","221602656_Linear_Regions_Are_All_You_Need","221477308_Checking_Interference_with_Fractional_Permissions","221241198_Ynot_Dependent_types_for_imperative_programs","220880915_Cyclone_A_safe_dialect_of_C","220752296_Enforcing_High-Level_Protocols_in_Low-Level_Software","220751884_Adoption_and_Focus_Practical_Linear_Types_for_Imperative_Programming","220404510_Semantic_Foundations_for_Typed_Assembly_Languages","322133414_A_logical_relation_for_monadic_encapsulation_of_state_proving_contextual_equivalences_in_the_presence_of_runST","320391425_Robust_and_compositional_verification_of_object_capability_patterns","319858536_Taming_undefined_behavior_in_LLVM","317596081_Taming_undefined_behavior_in_LLVM","316899254_A_relational_model_of_types-and-effects_in_higher-order_concurrent_separation_logic","316898653_Interactive_proofs_in_higher-order_concurrent_separation_logic","315341523_Temporary_Read-Only_Permissions_for_Separation_Logic","315341494_The_Essence_of_Higher-Order_Concurrent_Separation_Logic","312594297_A_Higher-Order_Logic_for_Concurrent_Termination-Preserving_Refinement","312013370_Interactive_proofs_in_higher-order_concurrent_separation_logic","312013353_A_relational_model_of_types-and-effects_in_higher-order_concurrent_separation_logic","311489076_CoGENT_Verifying_High-Assurance_File_System_Implementations","311482791_Higher-order_ghost_state","310824293_Refinement_through_restraint_bringing_down_the_cost_of_verification","310824189_Higher-order_ghost_state","305744838_Cogent_Verifying_High-Assurance_File_System_Implementations","304286669_Crust_A_Bounded_Verifier_for_Rust_N","303011829_Dependent_types_and_multi-monadic_effects_in_F","301274048_Dependent_types_and_multi-monadic_effects_in_F","291411519_Views","287498891_The_Design_and_Formalization_of_Mezzo_a_Permission-Based_Programming_Language","282926793_Iris_Monoids_and_Invariants_as_an_Orthogonal_Basis_for_Concurrent_Reasoning","267672965_Program_logics_for_certified_compilers","262909008_L3_A_Linear_Language_with_Locations","262348467_Superficially_Substructural_Types","262314773_Fictional_Separation_Logic","262287363_Views_Compositional_Reasoning_for_Concurrent_Programs","262162435_Foundations_of_C","261554594_Impredicative_Concurrent_Abstract_Predicates","261451810_Foundational_proof-carrying_code","257285824_A_Syntactic_Approach_to_Type_Soundness","225116287_Exception-Safety_in_Generic_Components","222459696_A_Theory_of_Type_Polymorphism_in_Programming","221602755_Deny-Guarantee_Reasoning","221509693_Making_the_usage_of_STL_safe","221496189_Concurrent_Abstract_Predicates","221442658_Foundational_Proof-Carrying_Code","220997193_A_Relational_Modal_Logic_for_Higher-Order_Stateful_ADTs","220688771_Compiling_with_Continuations","216817423_Practical_Affine_Types","213879130_Semantics_of_Types_for_Mutable_State","220404293_An_indexed_model_of_recursive_types_for_foundational_proof-carrying_code","220315927_Intentional_Interpretations_of_Functionals_of_Finite_Type_I","213880881_Lambda-Definability_and_Logical_Relations"]}