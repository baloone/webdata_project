{"id":"315466480_Detecting_Trivial_Mutant_Equivalences_via_Compiler_Optimisations","abstract":"Mutation testing realises the idea of fault-based testing, i.e., using artificial defects to guide the testing process. It is used to evaluate the adequacy of test suites and to guide test case generation. It is a potentially powerful form of testing, but it is well-known that its effectiveness is inhibited by the presence of equivalent mutants. We recently studied Trivial Compiler Equivalence (TCE) as a simple, fast and readily applicable technique for identifying equivalent mutants for C programs. In the present work, we augment our findings with further results for the Java programming language. TCE can remove a large portion of all mutants because they are determined to be either equivalent or duplicates of other mutants. In particular, TCE equivalent mutants account for 7.4% and 5.7% of all C and Java mutants, while duplicated mutants account for a further 21% of all C mutants and 5.4% Java mutants, on average. With respect to a benchmark ground truth suite (of known equivalent mutants), approximately 30% (for C) and 54% (for Java) are TCE equivalent. It is unsurprising that results differ between languages, since mutation characteristics are language-dependent. In the case of Java, our new results suggest that TCE may be particularly effective, finding almost half of all equivalent mutants.","authors":["Marinos Kintis","Mike Papadakis","Yue Jia","Nicos Malevris"],"meta":["March 2017IEEE Transactions on Software Engineering PP(99):1-1","DOI:10.1109/TSE.2017.2684805"],"references":["292754417_ProteumIM_20_An_integrated_mutation_testing_environment","282378950_Sound_and_Quasi-Complete_Detection_of_Infeasible_Test_Requirements","281584658_Trivial_Compiler_Equivalence_A_Large_Scale_Empirical_Study_of_a_Simple_Fast_and_Effective_Equivalent_Mutant_Detection_Technique","279773187_Overcoming_the_Equivalent_Mutant_Problem_A_Systematic_Literature_Review_and_a_Comparative_Experiment_of_Second_Order_Mutation","271550078_Identifying_More_Equivalent_Mutants_via_Code_Similarity","269304272_Probability-Based_Semantic_Interpretation_of_Mutants","267837073_Experimental_Evaluation_of_SDL_and_One-Op_Mutation_for_C","262317868_Constraint-Based_Automatic_Test_Data_Generation","261248337_Isolating_First_Order_Equivalent_Mutants_via_Second_Order_Mutation","261079309_Using_Non-redundant_Mutation_Operators_and_Test_Suite_Prioritization_to_Achieve_Efficient_and_Scalable_Mutation_Analysis","239761017_Better_predicate_testing","236980420_The_Soot_framework_for_Java_program_analysis_a_retrospective","229011927_Using_Constraints_for_Equivalent_Mutant_Detection","228609925_MILU_A_Customizable_Runtime-Optimized_Higher_Order_Mutation_Testing_Tool_for_the_Full_C_Language","224332299_Constructing_Subtle_Faults_Using_Higher_Order_Mutation_Testing","224115987_Judy_-_A_mutation_testing_tool_for_Java","221555692_Sufficient_mutation_operators_for_measuring_test_effectiveness","221554374_Is_operator-based_mutant_selection_superior_to_random_mutant_selection","221553870_Experiments_of_the_Effectiveness_of_Dataflow-_and_Controlflow-Based_Test_Adequacy_Criteria","221542064_Automatic_Mutation_Test_Case_Generation_via_Dynamic_Symbolic_Execution","220773040_Evaluating_Mutation_Testing_Alternatives_A_Collateral_Experiment","220740068_How_to_Overcome_the_Equivalent_Mutant_Problem_and_Achieve_Tailored_Selective_Mutation_Using_Co-evolution","220719886_An_Empirical_Evaluation_of_the_First_and_Second_Order_Mutation_Testing_Strategies","220516429_Using_Program_Slicing_to_Assist_in_the_Detection_of_Equivalent_Mutants","317335456_Analysing_and_Comparing_the_Effectiveness_of_Mutation_Testing_Tools_A_Manual_Study","316985429_Angels_and_monsters_An_empirical_investigation_of_potential_test_effectiveness_and_efficiency_improvement_from_strongly_subsuming_higher_order_mutation","316985252_A_Study_of_Equivalent_and_Stubborn_Mutation_Operators_using_Human_Analysis_of_Equivalence","309611828_Analyzing_the_validity_of_selective_mutation_with_dominator_mutants","306283788_An_analysis_of_the_relationship_between_conditional_entropy_and_failed_error_propagation_in_software_testing","305026954_Threats_to_the_validity_of_mutation-based_test_assessment","271455697_Establishing_Theoretical_Minimal_Sets_of_Mutants","269304186_Using_Data_Flow_Patterns_for_Equivalent_Mutant_Detection","269304108_An_Empirical_Comparison_of_Combinatorial_and_Random_Testing","267455849_Mitigating_the_effects_of_equivalent_mutants_with_mutant_classification_strategies","264487477_Covering_and_Uncovering_Equivalent_Mutants","262344130_Reducing_mutation_costs_through_uncovered_mutants","262168126_Faster_mutation_testing_inspired_by_test_prioritization_and_reduction","261487124_Empirical_Evaluation_of_the_Statement_Deletion_Mutation_Operator","260649024_An_Empirical_Evaluation_of_Mutation_Testing_for_Improving_the_Test_Quality_of_Safety-Critical_Software","260648938_Validating_Second-Order_Mutation_at_System_Level","247571837_Software_Fault_Injection_Inoculating_Programs_Against_Errors","243449939_Heuristics_for_Determining_Equivalence_of_Program_Mutations","224468519_The_Impact_of_Equivalent_Mutants","223091511_Reducing_the_Cost_of_Mutation_Testing_An_Empirical_Study","221560151_Strong_higher_order_mutation-based_test_data_generation","220854753_Software_Error_Analysis_A_Real_Case_Study_Involving_Real_Faults_and_Mutations","220854752_Efficient_mutation_testing_by_checking_invariant_violations","220516452_Decreasing_the_cost_of_mutation_testing_with_2-order_mutants","220516324_MuJava_An_automated_class_mutation_system","220375578_Multi_Objective_Higher_Order_Mutation_Testing_with_Genetic_Programming","220069671_An_Analysis_and_Survey_of_the_Development_of_Mutation_Testing","220281668_An_Experimental_Evaluation_of_Data_Flow_and_Mutation_Testing","220277863_On_guiding_the_augmentation_of_an_automated_test_suite_via_mutation_analysis","220198298_Two_Notions_of_Correctness_and_Their_Relation_to_Testing","27525471_On_mutation"]}