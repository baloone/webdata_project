{"id":"315748377_Profunctor_Optics_Modular_Data_Accessors","abstract":"CONTEXT: Data accessors allow one to read and write components of a data structure, such as the fields of a record, the variants of a union, or the elements of a container. These data accessors are collectively known as optics; they are fundamental to programs that manipulate complex data. INQUIRY: Individual data accessors for simple data structures are easy to write, for example as pairs of \"getter\" and \"setter\" methods. However, it is not obvious how to combine data accessors, in such a way that data accessors for a compound data structure are composed out of smaller data accessors for the parts of that structure. Generally, one has to write a sequence of statements or declarations that navigate step by step through the data structure, accessing one level at a time - which is to say, data accessors are traditionally not first-class citizens, combinable in their own right. APPROACH: We present a framework for modular data access, in which individual data accessors for simple data structures may be freely combined to obtain more complex data accessors for compound data structures. Data accessors become first-class citizens. The framework is based around the notion of profunctors, a flexible generalization of functions. KNOWLEDGE: The language features required are higher-order functions (\"lambdas\" or \"closures\"), parametrized types (\"generics\" or \"abstract types\"), and some mechanism for separating interfaces from implementations (\"abstract classes\" or \"modules\"). We use Haskell as a vehicle in which to present our constructions, but languages such as Java, C#, or Scala that provide the necessary features should work just as well. GROUNDING: We provide implementations of all our constructions, in the form of a literate program: the manuscript file for the paper is also the source code for the program, and the extracted code is available separately for evaluation. We also prove the essential properties demonstrating that our profunctor-based representations are precisely equivalent to the more familiar concrete representations. IMPORTANCE: Our results should pave the way to simpler ways of writing programs that access the components of compound data structures.","authors":["Matthew Pickering","Jeremy Gibbons","Nicolas Wu"],"meta":["March 2017The Art Science and Engineering of Programming 1(2)","DOI:10.22152/programming-journal.org/2017/1/7"],"references":["287972676_Applicative_Bidirectional_Programming_with_Lenses","260107906_A_Representation_Theorem_for_Second-Order_Functionals","226247817_Datatype-Generic_Programming","221282345_Scrap_Your_Boilerplate_A_Practical_Design_Pattern_for_Generic_Programming","220676565_The_essence_of_the_Iterator_pattern","215446169_Applicative_Programming_with_Effects","43921655_Combinators_for_bidirectional_tree_transformations_A_linguistic_approach_to_the_view-update_problem","262346592_Understanding_Idiomatic_Traversals_Backwards_and_Forwards","234779532_Update_Semantics_of_Relational_Views","221562953_Uniform_Boilerplate_and_List_Processing_Or_Scrap_Your_Scary_Types","221303515_Monads_for_Functional_Programming","220676810_A_pattern_for_almost_compositional_functions","220607089_Fundamental_Concepts_in_Programming_Languages","50378436_Functor_is_to_Lens_as_Applicative_is_to_Biplate_Introducing_Multiplate","37442102_Matching_Objects_with_Patterns","2626649_Compositional_References_for_Stateful_Functional_Programming"]}