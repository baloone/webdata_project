{"id":"262365220_An_O1_RMRs_leader_election_algorithm","abstract":"The leader election problem is a fundamental coordination problem. We present leader election algorithms for multiprocessor systems where processes communicate by reading and writing shared memory asynchronously and do not fail. In particular, we consider the cache-coherent (CC) and distributed shared memory (DSM) models of such systems. We present leader election algorithms that perform a constant number of remote memory references (RMRs) in the worst case. Our algorithms use splitter-like objects [J. Anderson and M. Moir, Sci. Comput. Programming, 25 (1995), pp. 1-39; H. Attiya and A. Fouren, Theory Comput. Syst., 31 (2001), pp. 642-664] in a novel way, by organizing active processes into teams that share work. As there is an $\\Omega(\\log n)$ lower bound on the RMR complexity of mutual exclusion for $n$ processes using reads and writes only [H. Attiya, D. Hendler, and W. Woelfel, in Proceedings of the ACM Symposium on Theory of Computing, ACM, New York, 2008, pp. 217-226], our result separates the mutual exclusion and leader election problems in terms of RMR complexity in both the CC and DSM models. Our result also implies that any algorithm using reads, writes, and one-time test-and-set objects can be simulated by an algorithm using reads and writes with only a constant blowup of the RMR complexity; proving this is easy in the CC model but presents subtle challenges in the DSM model, as we explain later. Anderson, Herman, and Kim raise the question of whether conditional primitives such as test-and-set and compare-and-swap can be used, along with reads and writes, to solve mutual exclusion with better worst-case RMR complexity than is possible using reads and writes only [Distributed Computing, 16 (2003), pp. 75-110]. We provide a negative answer to this question in the case of implementing one-time test-and-set.","authors":["Wojciech Golab","Danny Hendler","Philipp Woelfel"],"meta":["May 2010SIAM Journal on Computing 39(7):2726-2760","DOI:10.1137/070686445"],"references":["221591507_Tight_RMR_Lower_Bounds_for_Mutual_Exclusion_and_Other_Problems","221344136_Constant-RMR_implementations_of_CAS_and_other_synchronization_primitives_using_read_and_write_operations","220616440_An_O_1_RMRs_leader_election_algorithm","200030230_Linearizability_A_Correctness_Condition_for_Concurrent_Objects","3970933_Hybrid_computation_with_an_attractor_neural_network","2815130_Contention_in_Shared_Memory_Algorithms","2648040_Wait-Free_Synchronization","268266057_An_On_log_n_Lower_Bound_on_the_Cost_of_Mutual_Exclusion","226558524_An_improved_lower_bound_for_the_time_complexity_of_mutual_exclusion","225775101_A_Time_Complexity_Bound_for_Adaptive_Mutual_Exclusion","225532354_Adaptive_and_efficient_mutual_exclusion","222457853_Wait-free_algorithms_for_fast_long-lived_renaming","221344094_Nonatomic_mutual_exclusion_with_local_spinning","221343715_Tight_Bounds_for_Shared_Memory_Symmetric_Mutual_Exclusion_Problems","220567108_Adaptive_Solutions_to_the_Mutual_Exclusion_Problem","220567057_Shared-memory_mutual_exclusion_Major_research_trends_since_1986","220420637_Solution_of_a_Problem_in_Concurrent_Programming_Control","38002172_An_Omegan_log_n_Lower_Bound_on_the_Cost_of_Mutual_Exclusion","4147213_Transformations_of_Mutual_Exclusion_Algorithms_from_the_Cache-Coherent_Model_to_the_Distributed_Shared_Memory_Model","3515025_Results_about_fast_mutual_exclusion","2811656_The_Communication_Requirements_of_Mutual_Exclusion","2633894_A_Fine-Grained_Solution_to_the_Mutual_Exclusion_Problem","2622308_TimeContention_Trade-Offs_for_Multiprocessor_Synchronization","2434268_Adaptive_And_Efficient_Algorithms_For_Lattice_Agreement_And_Renaming","2331658_Adaptive_Mutual_Exclusion_with_Local_Spinning"]}