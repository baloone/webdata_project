{"id":"321025154_Refinement_Reflection_Complete_Verification_with_SMT","abstract":"We introduce Refinement Reflection, a new framework for building SMT-based deductive verifiers. The key idea is to reflect the code implementing a user-defined function into the function's (output) refinement type. As a consequence, at uses of the function, the function definition is instantiated in the SMT logic in a precise fashion that permits decidable verification. Reflection allows the user to write equational proofs of programs just by writing other programs using pattern-matching and recursion to perform case-splitting and induction. Thus, via the propositions-as-types principle, we show that reflection permits the specification of arbitrary functional correctness properties. Finally, we introduce a proof-search algorithm called Proof by Logical Evaluation that uses techniques from model checking and abstract interpretation, to completely automate equational reasoning. We have implemented reflection in Liquid Haskell and used it to verify that the widely used instances of the Monoid, Applicative, Functor, and Monad typeclasses actually satisfy key algebraic laws required to make the clients safe, and have used reflection to build the first library that actually verifies assumptions about associativity and ordering that are crucial for safe deterministic parallelism.","authors":["Niki Vazou","Anish Tondwalkar","Vikraman Choudhury","Ryan G. Scott"],"meta":["November 2017Proceedings of the ACM on Programming Languages 2(POPL)","DOI:10.1145/3158141"],"references":["267982095_Full-Speed_Deterministic_Bit-Accurate_Parallel_Floating-Point_Summation_on_Multi-_and_Many-Core_Architectures","267157079_Type_Targeted_Testing","266660663_Refinement_Types_For_Haskell","262312016_Abstract_Refinement_Types","262211622_Zeno_An_Automated_Prover_for_Properties_of_Recursive_Data_Structures","262168162_HALO_Haskell_to_Logic_through_Denotational_Semantics","248801042_Towards_a_practical_programming_language_based_on_dependent_type_theory","243477047_Abstract_interpretation_a_unijied_lattice_model_for_static_analysis_of_programs","228107036_The_Parametric_lambda-Calculus_a_Metamodel_for_Computation","221602507_Dependent_Types_for_Low-Level_Programming","221562943_S_A_monad_for_deterministic_parallelism","221221795_Dynamic_Typing_with_Dependent_Types","220997507_Abstract_Interpretation_A_Unified_Lattice_Model_for_Static_Analysis_of_Programs_by_Construction_or_Approximation_of_Fixpoints","220805711_Extending_Sledgehammer_with_SMT_Solvers","320793519_A_tale_of_two_provers_verifying_monoidal_string_matching_in_liquid_Haskell_and_Coq","316857436_HALO_haskell_to_logic_through_denotational_semantics","311487898_Programming_up_to_Congruence","311475486_Decision_procedures_for_algebraic_data_types_with_abstractions","311473785_Low-level_liquid_types","305791064_Refinement_types_for_TypeScript","305258491_Trigger_Selection_Strategies_to_Stabilize_Program_Verifiers","303968855_Combining_Proofs_and_Programs_in_a_Dependently_Typed_Language","303773816_Occurrence_typing_modulo_theories","303773674_Refinement_Types_for_TypeScript","303773511_Cartesian_hoare_logic_for_verifying_k-safety_properties","303011829_Dependent_types_and_multi-monadic_effects_in_F","302181298_Verified_Calculations","301274048_Dependent_types_and_multi-monadic_effects_in_F","300474434_Computing_with_an_SMT_Solver","298725106_Verifying_Relational_Properties_of_Functional_Programs_by_First-Order_Refinement","284709907_Propositions_as_types","284579283_Occurrence_Typing_Modulo_Theories","281407240_Reasoning_with_the_HERMIT_tool_support_for_equational_reasoning_on_GHC_core_programs","276464649_Programming_up_to_Congruence","275748872_Investigations_into_Logical_Deduction","269199773_QuickCheck","266661004_Promoting_Functions_to_Type_Families_in_Haskell","262411034_Freeze_After_Writing_Quasi-Deterministic_Parallel_Programming_with_LVars","262217536_Combining_Proofs_and_Programs_in_a_Dependently_Typed_Language","249894040_Guarded_Commands_Nondeterminacy_and_Formal_Derivation","246048842_Eliminating_array_bounds_checks_through_dependent_types","242580932_Techniques_for_program_verification","242472424_Type-preserving_Compilation_for_End-to-end_Verification_of_Security_Enforcement_Preliminary_version","237123694_The_formulae-as-types_notion_of_construction","234815788_A_critique_of_Abelson_and_Sussman_or_why_calculating_is_better_than_scheming","225149162_Dafny_An_Automatic_Program_Verifier_for_Functional_Correctness","225147140_Satisfiability_Modulo_Recursive_Programs","221442755_Partial_Objects_In_Constructive_Type_Theory","220997770_Low-Level_Liquid_Types","220997158_Model_Checking_and_Abstraction","220676814_Algebra_of_programming_in_Agda_Dependent_types_for_relational_program_derivation","220458641_Algebraic_Identities_for_Program_Calculation","220404689_Hybrid_Type_Checking","220751922_Type-preserving_Compilation_for_End-to-end_Verification_of_Security_Enforcement","220695897_A_Discipline_of_Programming"]}