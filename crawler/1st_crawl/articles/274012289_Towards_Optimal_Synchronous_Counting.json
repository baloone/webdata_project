{"id":"274012289_Towards_Optimal_Synchronous_Counting","abstract":"Consider a complete communication network of $n$ nodes, where the nodes\nreceive a common clock pulse. We study the synchronous $c$-counting problem:\ngiven any starting state and up to $f$ faulty nodes with arbitrary behaviour,\nthe task is to eventually have all correct nodes counting modulo $c$ in\nagreement. Thus, we are considering algorithms that are self-stabilizing\ndespite Byzantine failures. In this work, we give new algorithms for the\nsynchronous counting problem that (1) are deterministic, (2) have linear\nstabilisation time in $f$, (3) use a small number of states, and (4) achieve\nalmost-optimal resilience. Prior algorithms either resort to randomisation, use\na large number of states, or have poor resilience. In particular, we achieve an\nexponential improvement in the space complexity of deterministic algorithms,\nwhile still achieving linear stabilisation time and almost-linear resilience.","authors":["Christoph Lenzen","Joel Rybicki","Jukka Suomela"],"meta":["March 2015","DOI:10.1145/2767386.2767423","SourcearXiv"],"references":["236248234_Synchronous_Counting_and_Computational_Algorithm_Design","221343677_Fast_Self-Stabilizing_Byzantine_Tolerant_Digital_Clock_Synchronization","221343529_Bounds_on_Information_Exchange_for_Byzantine_Agreement","221233814_On_Self-stabilizing_Synchronous_Actions_Despite_Byzantine_Attacks","220431204_Bounds_on_Information_Exchange_for_Byzantine_Agreement","297764937_Synchronous_counting_and_computational_algorithm_design","269858936_Introduction_Self_Stabilization","234831006_Reaching_Agreement_in_the_Presence_of_Faults","220688572_Self-Stabilization","220431719_Reaching_Agreement_in_the_Presence_of_Faults","220114448_A_Lower_Bound_for_the_Time_to_Assure_Interactive_Consistency","3501892_Towards_optimal_distributed_consensus","2246664_Self-Stabilizing_Clock_Synchronization_in_the_Presence_of_Byzantine_Faults"]}