{"id":"334586548_The_firing_squad_problem_revisited","abstract":"In the classical firing squad problem, an unknown number of nodes represented by identical finite states machines is arranged on a line and in each time unit each node may change its state according to its neighbors' states. Initially all nodes are passive, except one specific node located at an end of the line, which issues a fire command. This command needs to be propagated to all other nodes, so that eventually all nodes simultaneously enter some designated “firing” state.\nA natural extension of the firing squad problem, introduced in this paper, allows each node to postpone its participation in the squad for an arbitrary time, possibly forever, and firing is allowed only after all nodes decided to participate. This variant is highly relevant in the context of decentralized distributed computing, where processes have to coordinate for initiating various tasks simultaneously.\nThe main goal of this paper is to study the above variant of the firing squad problem under the assumptions that the nodes are infinite state machines, and that the inter-node communication links can be changed arbitrarily in each time unit, i.e., are defined by a dynamic graph. In this setting, we study the following fundamental question: what connectivity requirements enable a solution to the firing squad problem?\nOur main result is an exact characterization of the dynamic graphs for which the firing squad problem can be solved. When restricted to static directed graphs, this characterization implies that the problem can be solved if and only if the graph is strongly connected. We also discuss how information on the number of nodes or on the diameter of the network, and the use of randomization, can improve the solutions to the problem.","authors":["Bernadette Charron-Bost","Shlomo Moran"],"meta":["July 2019Theoretical Computer Science 793(1)","DOI:10.1016/j.tcs.2019.07.023"],"references":["331982905_Time-Varying_Graphs_and_Dynamic_Networks","224252044_Distributed_Anonymous_Discrete_Function_Computation","221344109_Computing_separable_functions_via_gossip","220617237_The_Distributed_Firing_Squad_Problem","220616485_Authenticated_Algorithms_for_Byzantine_Agreement","220432431_Early_Stopping_in_Byzantine_Agreement","220404865_Virtual_Time","49457706_Schiper_A_The_Heard-Of_model_computing_in_distributed_systems_with_benign_faults_Distributed_Computing_221_49-71","313916514_Token_Dissemination_in_Geometric_Dynamic_Networks","312943070_The_Heard-Of_Model_Computing_in_Distributed_Systems_with_Benign_Failures","309613576_Near-Optimal_Self-stabilising_Counting_and_Firing_Squads","279815771_Distributed_computation_in_wireless_and_dynamic_networks","262282504_Natural_algorithms_and_influence_systems","242442270_The_firing_squad_synchronization_problem","234831006_Reaching_Agreement_in_the_Presence_of_Faults","228057613_Distributed_Computation_in_Dynamic_Networks","224732353_Resynch_Procedures_and_a_Fail-Safe_Network_Protocol","223045343_The_firing_squad_synchronization_problem_for_graphs","222321591_Knowledge_and_common_knowledge_in_a_Byzantine_environment_Crash_failures","221343223_Coordinated_consensus_in_dynamic_networks","220566957_Simulating_Authenticated_Broadcasts_to_Derive_Simple_Fault-Tolerant_Algorithms","220431719_Reaching_Agreement_in_the_Presence_of_Faults","220247660_A_Generalized_Firing_Squad_Problem","2565868_The_Byzantine_Firing_Squad_Problem"]}