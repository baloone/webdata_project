{"id":"312545420_Semantics-Based_Obfuscation-Resilient_Binary_Code_Similarity_Comparison_with_Applications_to_Software_and_Algorithm_Plagiarism_Detection","abstract":"Existing code similarity comparison methods, whether source or binary code based, are mostly not resilient to obfuscations. Identifying similar or identical code fragments among programs is very important in some applications. For example, one application is to detect illegal code reuse. In the code theft cases, emerging obfuscation techniques have made automated detection increasingly difficult. Another application is to identify cryptographic algorithms which are widely employed by modern malware to circumvent detection, hide network communications, and protect payloads among other purposes. Due to diverse coding styles and high programming flexibility, different implementation of the same algorithm may appear very distinct, causing automatic detection to be very hard, let alone code obfuscations are sometimes applied. In this paper, we propose a binary-oriented, obfuscation-resilient binary code similarity comparison method based on a new concept, longest common subsequence of semantically equivalent basic blocks, which combines rigorous program semantics with longest common subsequence based fuzzy matching. We model the semantics of a basic block by a set of symbolic formulas representing the input-output relations of the block. This way, the semantic equivalence (and similarity) of two blocks can be checked by a theorem prover. We then model the semantic similarity of two paths using the longest common subsequence with basic blocks as elements. This novel combination has resulted in strong resiliency to code obfuscation. We have developed a prototype. The experimental results show that our method can be applied to software plagiarism and algorithm detection, and is effective and practical to analyze real-world software.","authors":["Lannan Luo","Jiang Ming","Dinghao Wu","Peng Liu"],"meta":["January 2017IEEE Transactions on Software Engineering PP(99):1-1","DOI:10.1109/TSE.2017.2655046"],"references":["289903978_A_Framework_for_Evaluating_Mobile_App_Repackaging_Detection_Algorithms","266660618_ViewDroid_Towards_obfuscation-resilient_mobile_application_repackaging_detection","262154598_Aligot_Cryptographic_function_identification_in_obfuscated_binary_programs","241623856_Detecting_Repackaged_Smartphone_Applications_in_Third-Party_Android_Marketplaces","228337172_Renovo_A_hidden_code_extractor_for_packed_executables","221655405_Impeding_Malware_Analysis_Using_Conditional_Code_Obfuscation","221653862_GPLAG_Detection_of_software_plagiarism_by_program_dependence_graph_analysis","221632077_ReFormat_Automatic_Reverse_Engineering_of_Encrypted_Messages","221609315_EXE_Automatically_Generating_Inputs_of_Death","221554617_Scalable_Detection_of_Semantic_Clones","221554444_Value-based_program_characterization_and_its_application_to_software_plagiarism_detection","221427502_Automated_Identification_of_Cryptographic_Primitives_in_Binary_Programs","221402853_A_Decision_Procedure_for_Bit-Vectors_and_Arrays","220989942_LOCO_an_interactive_code_Deobfuscation_tool","220752310_DART_Directed_automated_random_testing","220751886_Semantics-Aware_Trace_Analysis","313659794_Design_and_evaluation_of_birthmarks_for_detecting_theft_of_Java_programs","312867253_Automated_whitebox_fuzz_testing","306123933_Fast_scalable_detection_of_piggybacked_mobile_applications","303948585_Deviation-Based_Obfuscation-Resilient_Program_Equivalence_Checking_With_Application_to_Software_Plagiarism_Detection","302568334_Structural_Comparison_of_Executable_Objects","301428625_Semantics-based_obfuscation-resilient_binary_code_similarity_comparison_with_applications_to_software_plagiarism_detection","289899636_AnDarwin_Scalable_Detection_of_Semantically_Similar_Android_Applications","285936932_Program_Logic_Based_Software_Plagiarism_Detection","277641613_Program_Characterization_Using_Runtime_Values_and_Its_Application_to_Software_Plagiarism_Detection","267436364_iBinHunt_Binary_Hunting_with_Inter-procedural_Control_Flow","266656086_Achieving_accuracy_and_scalability_simultaneously_in_detecting_application_clones_on_Android_markets","266513263_The_ultimate_challenge_The_3x1_problem","265959861_Unpredictable_iterations","265944933_Android_From_Reversing_to_Decompilation","262321614_A_first_step_towards_algorithm_plagiarism_detection","262315700_Juxtapp_A_Scalable_System_for_Detecting_Code_Reuse_among_Android_Applications","255564356_SYMDIFF_A_Language-Agnostic_Semantic_Diff_Tool_for_Imperative_Programs","247442902_Introduction_To_Algorithms","243785180_The_Art_of_Computer_Virus_Research_and_Defense","239007241_Structured_testing_a_software_testing_methodology_using_the_cyclomatic_complexity_metric","234824734_Binary_obfuscation_using_signals","225189214_Dynamic_Analysis_of_Malicious_Code","225172918_Execution_Generated_Test_Cases_How_to_Make_Systems_Code_Crash_Itself","224679696_PolyUnpack_Automating_the_Hidden-Code_Extraction_of_Unpack-Executing_Malware","221609243_Behavior_based_software_theft_detection","221609111_Dispatcher_Enabling_active_botnet_infiltration_using_automatic_protocol_reverse-engineering","221302741_CIL_Intermediate_Language_and_Tools_for_Analysis_and_Transformation_of_C_Programs","220905316_Replacement_Attacks_on_Behavior_Based_Software_Birthmark","220905153_Detecting_Software_Theft_via_Whole_Program_Path_Birthmarks","220883146_A_dynamic_birthmark_for_Java","220851853_KLEE_Unassisted_and_Automatic_Generation_of_High-Coverage_Tests_for_Complex_Systems_Programs","220784845_The_Superdiversifier_Peephole_Individualization_for_Software_Protection","220739230_BinHunt_Automatically_Finding_Semantic_Differences_in_Binary_Programs","220692549_Introduction_to_Algorithms_3_ed","220593611_EXE_Automatically_Generating_Inputs_of_Death","37987523_A_Taxonomy_of_Obfuscating_Transformations","4303459_OmniUnpack_Fast_Generic_and_Safe_Unpacking_of_Malware","3437907_Toward_Automated_Dynamic_Malware_Analysis_Using_CWSandbox","3653384_On_finding_duplication_and_near-duplication_in_large_softwaresystems"]}