{"id":"221621820_The_Join_Calculus_A_Language_for_Distributed_Mobile_Programming","abstract":"In these notes, we give an overview of the join calculus, its semantics, and its equational theory. The join calculus is a language that models distributed and mobile programming. It is characterized by an explicit notion of locality, a strict adherence to local synchronization, and a direct embedding of the ML programming language. The join calculus is used as the basis for several distributed languages and implementations, such as JoCaml and functional nets.\nLocal synchronization means that messages always travel to a set destination, and can interact only after they reach that destination; this is required for an efficient implementation. Specifically, the join calculus uses MLâ€™s function bindings and pattern-matching on messages to program these synchronizations in a declarative manner.\nFormally, the language owes much to concurrency theory, which provides a strong basis for stating and proving the properties of asynchronous programs. Because of several remarkable identities, the theory of process equivalences admits simplifications when applied to the join calculus. We prove several of these identities, and argue that equivalences for the join calculus can be rationally organized into a five-tiered hierarchy, with some trade-off between expressiveness and proof techniques.\nWe describe the mobility extensions of the core calculus, which allow the programming of agent creation and migration. We briefly present how the calculus has been extended to model distributed failures on the one hand, and cryptographic protocols on the other.","authors":["Cedric Fournet","Georges Gonthier"],"meta":["January 2000Lecture Notes in Computer Science 25:268-332","DOI:10.1007/3-540-45699-6_6","SourceDBLP","Conference: Applied Semantics, International Summer School, APPSEM 2000, Caminha, Portugal, September 9-15, 2000, Advanced Lectures"],"references":["257643041_Mobile_Ambients","251696632_Compiling_Join-Patterns1","227324777_Fair_testing","226510996_Decoding_Choice_Encodings","221221785_An_Asynchronous_Distributed_Implementation_of_Mobile_Ambients","220703428_Applications_of_Fair_Testing","220676793_A_Foundation_for_Actor_Computation","312653734_Barbed_bisimulation_In_Proceedings_of_International_Colloquium_on_Automata_Languages_and_Programming_ICALP","310750253_Concurrency_and_automata_on_infinite_sequences","292449098_Expressing_mobility_in_process_algebras_first-order_and_higher-order_paradigms","282784163_Typed_language_for_distributed_mobile_processes","270956456_A_Calculus_of_Mobile_Processes_Parts_I_and_II","270956368_Mobile_Ambients","266425464_The_p-Calculus_A_Theory_of_Mobile_Processes","262162533_On_bisimulations_of_the_asynchronous_pgr-calculus","246149776_Expressing_mobility_in_process_algebras_First-order_and_higher-order_paradigms","245624208_CCS-A_Calculus_for_Communicating_Systems","243536627_X-calculus_models_of_programming_languages","242506565_Migration_of_light-weight_processes_in_Emerald","242449567_The_reexive_chemical_abstract_machine_and_the_joincalculus","240444412_A_distributed_implementation_of_Ambients","238750465_The_reflexive_chemical_abstract_nmr'hint'_and_i_lie_join-calculus","235089022_Lambda-calculus_models_of_programming_languages","234803172_Communication_and_Concurrency","234779594_Fine-grained_mobility_in_the_Emerald_system","232628625_Secure_Communications_Processing_for_Distributed_Languages","225508589_On_bisimulations_for_the_asynchronous_p-calculus","224001269_Communication_and_Concurrency","222706079_A_hierarchy_of_equivalences_for_asynchronous_calculi","222584775_Bisimulations_in_the_Join-Calculus","222477350_Chemical_abstract_machine","222449825_On_reduction-based_process_semantics","222286797_Compiling_Join-Patterns","221988120_Decoding_Choice_Encodings","221583937_Localities_and_Failures_Extended_Abstract","220997699_Authentication_Primitives_and_Their_Compilation","220997239_Combinatory_Representation_of_Mobile_Processes","220997136_Reflexive_CHAM_and_the_join-calculus","220995259_The_Complete_Axiomatization_of_Cs-congruence","220994027_An_Asynchronous_Model_of_Locality_Failurem_and_Process_Mobility","220910212_Fine-Grained_Mobility_in_the_Emerald_System_Extended_Abstract","220700882_The_Problem_of_Weak_Bisimulation_up_to''","220700704_The_Linear_Time_-_Branching_Time_Spectrum_II","220700486_Multiway_Synchrinizaton_Verified_with_Coupled_Simulation","220700438_Decoding_Choice_Encodings","220690524_Communicating_and_Mobile_Systems_The_p-Calculus","220690132_The_Pi-Calculus_-_a_theory_of_mobile_processes","220688100_A_Calculus_of_Communicating_System","220248383_A_Calculus_of_Mobile_Processes_I","220247575_A_Calculus_of_Mobile_Processes_II","3633834_Secure_network_objects","220155253_Some_Congruence_Properties_for_Pi-Calculus_Bisimilarities","220131682_The_GAMMA_Model_and_Its_Discipline_of_Programming","3824431_Jocaml_mobile_agents_for_Objective-Caml","3763277_Secure_Implementation_of_Channel_Abstractions"]}