{"id":"301375726_Using_Crash_Hoare_logic_for_certifying_the_FSCQ_file_system","abstract":"FSCQ is the first file system with a machine-checkable proof (using the Coq proof assistant) that its implementation meets its specification and whose specification includes crashes. FSCQ provably avoids bugs that have plagued previous file systems, such as performing disk writes without sufficient barriers or forgetting to zero out directory blocks. If a crash happens at an inopportune time, these bugs can lead to data loss. FSCQ's theorems prove that, under any sequence of crashes followed by reboots, FSCQ will recover the file system correctly without losing data.\nTo state FSCQ's theorems, this paper introduces the Crash Hoare logic (CHL), which extends traditional Hoare logic with a crash condition, a recovery procedure, and logical address spaces for specifying disk states at different abstraction levels. CHL also reduces the proof effort for developers through proof automation. Using CHL, we developed, specified, and proved the correctness of the FSCQ file system. Although FSCQ's design is relatively simple, experiments with FSCQ running as a user-level file system show that it is sufficient to run Unix applications with usable performance. FSCQ's specifications and proofs required significantly more work than the implementation, but the work was manageable even for a small team of a few researchers.","authors":["Haogang Chen","Daniel Ziegler","Tej Chajed","Adam Chlipala"],"meta":["October 2015","DOI:10.1145/2815400.2815402","Conference: the 25th Symposium"],"references":["308853373_Inside_a_Verified_Flash_File_System_Transactions_and_Garbage_Collection","302574274_Jitk_A_Trustworthy_In-Kernel_Interpreter_Infrastructure","282484874_Verdi_A_Framework_for_Implementing_and_Formally_Verifying_Distributed_Systems","281589374_Fault-Tolerant_Resource_Reasoning","278244505_Fault-tolerant_Resource_Reasoning","276464932_Deep_Specifications_and_Certified_Abstraction_Layers","268761573_Formalizing_a_Hierarchical_File_System","266654943_File_systems_deserve_verification_too","265773590_Local_reasoning_for_the_POSIX_file_system","221612292_Formal_Modeling_and_Analysis_of_a_Flash_Filesystem_in_Alloy","221241344_Static_typing_for_a_faulty_lambda_calculus","221136392_An_Integrated_Formal_Methods_Tool-Chain_and_Its_Application_to_Verifying_a_File_System_Model","220910193_SeL4_Formal_verification_of_an_OS_kernel","220851747_SQCK_A_Declarative_File_System_Checker","220752349_Fault-tolerant_typed_assembly_language","220102281_A_Mini_Challenge_Build_a_Verifiable_Filesystem","200030230_Linearizability_A_Correctness_Condition_for_Concurrent_Objects","37794752_Formal_Verification_of_a_Realistic_Compiler","24000534_A_Formally_Verified_Compiler_Back-end","4371244_Experiences_with_Formal_Specification_of_Fault-Tolerant_File_Systems","4331135_POSIX_and_the_Verification_Grand_Challenge_a_roadmap","348350723_Specifying_crash_safety_for_storage_systems","314879834_Mostly-automated_verification_of_low-level_programs_in_computational_separation_logic","313550915_An_Axiomatic_Basis_of_Computer_Programming","312942990_On_Verifying_a_File_System_Implementation","305628810_Verifying_quantitative_reliability_for_programs_that_execute_on_unreliable_hardware","291411519_Views","279811038_The_scalable_commutativity_rule_designing_scalable_software_for_multicore_processors","278650576_Development_of_a_Verified_Flash_File_System","268455817_The_bedrock_structured_programming_system","262642327_Verification_of_a_Virtual_Filesystem_Switch","262327073_Verifying_Quantitative_Reliability_of_Programs_That_Execute_on_Unreliable_Hardware","262287363_Views_Compositional_Reasoning_for_Concurrent_Programs","262203747_The_Scalable_Commutativity_Rule_Designing_Scalable_Software_for_Multicore_Processors","262168777_The_Bedrock_Structured_Programming_System_Combining_Generative_Metaprogramming_and_Hoare_Logic_in_an_Extensible_Program_Verifier","261858572_A_Study_of_Linux_File_System_Evolution","251563039_EXPLODE_A_Lightweight_General_Approach_to_Finding_Serious_Errors_in_Storage_Systems","248032511_The_temporal_logic_of_ac-tions","242544406_Aries_a_transaction_recovery_method_supporting_fine-granularity_locking_and_partial_rollbacks_using_writeahead_logging","237130303_FUSE_Filesystem_in_Userspace","236340576_Temporal_logic_of_actions","220851778_Using_Model_Checking_to_Find_Serious_File_System_Errors_Awarded_Best_Paper","220851675_EXPLODE_A_Lightweight_General_System_for_Finding_Serious_Storage_System_Errors","220752273_Mostly-Automated_Verification_of_Low-Level_Programs_in_Computational_Separation_Logic","220752027_Safe_to_the_Last_Instruction_Automated_Verification_of_a_Type-Safe_Operating_System","220744386_On_Verifying_a_File_System_Implementation","220439428_Using_model_checking_to_find_serious_file_system_errors","220225254_ARIES_A_Transaction_Recovery_Method_Supporting_Fine-Granularity_Locking_and_Partial_Rollbacks_Using_Write-Ahead_Logging","213886767_Hoare_CAR_An_axiomatic_basis_for_computer_programming_Commun_ACM_12_576-580","4323358_Formally_Proved_Anti-tearing_Properties_of_Embedded_C_Code","4238332_Automatically_generating_malicious_disks_using_symbolic_execution","3965916_Separation_logic_A_logic_for_shared_mutable_data_structures","2898228_An_Executable_Model_of_the_Synergy_File_System","2889420_A_Speci_cation_for_the_Synergy_File_System","2814406_The_Design_and_Implementation_of_a_Log-Structured_File_System"]}