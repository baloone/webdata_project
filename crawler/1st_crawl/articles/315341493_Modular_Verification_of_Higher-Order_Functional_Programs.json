{"id":"315341493_Modular_Verification_of_Higher-Order_Functional_Programs","abstract":"Fully automated verification methods for higher-order functional programs have recently been proposed based on higher-order model checking and/or refinement type inference. Most of those methods are, however, whole program analyses, suffering from the scalability problem. To address the problem, we propose a modular method for fully automated verification of higher-order programs. Our method takes a program consisting of multiple top-level functions as an input, and repeatedly applies procedures for (i) guessing refinement intersection types of each function in a counterexample-guided manner, and (ii) checking that each function indeed has the guessed refinement intersection types, until the whole program is proved/disproved to be safe. To avoid the whole program analysis, we introduce the notion of modular counterexamples, and utilize them in (i), and employ Sato et al.â€™s technique of reducing refinement type checking to assertion checking in (ii). We have implemented the proposed method as an extension to MoCHi, and confirmed its effectiveness through experiments.","authors":["Ryosuke Sato","Naoki Kobayashi"],"meta":["March 2017Lecture Notes in Computer Science","DOI:10.1007/978-3-662-54434-1_31","Conference: European Symposium on Programming"],"references":["268391822_Relatively_Complete_Counterexamples_for_Higher-Order_Programs","266660663_Refinement_Types_For_Haskell","221403402_The_Verus_Tool_A_Quantitative_Approach_to_the_Formal_Verification_of_Real-Time_Systems","221336350_Dependent_type_inference_with_interpolants","220997331_Higher-order_multi-parameter_tree_transducers_and_recursion_schemes_for_program_verification","220752033_Predicate_Abstraction_and_CEGAR_for_Higher-Order_Model_Checking","314854531_Predicate_abstraction_and_CEGAR_for_higher-order_model_checking","309888961_Automating_relatively_complete_verification_of_higher-order_functional_programs","308960288_Higher-Order_Model_Checking_in_Direct_Style","303773727_Automatically_learning_shape_specifications","303011829_Dependent_types_and_multi-monadic_effects_in_F","300570962_Counter-example_complete_verification_for_higher-order_functions","300131575_Automata-Based_Abstraction_for_Automated_Verification_of_Higher-Order_Tree-Processing_Programs","294284620_Compositional_and_Lightweight_Dependent_Type_Inference_for_ML","287965986_Learning_Refinement_Types","286245865_Soft_contract_verification","283858812_Refinement_Type_Checking_via_Assertion_Checking","266859603_Why3_-_Where_Programs_Meet_Provers","262369807_Automating_Relatively_Complete_Verification_of_Higher-Order_Functional_Programs","262356782_Towards_a_scalable_software_model_checker_for_higher-order_programs","225149162_Dafny_An_Automatic_Program_Verifier_for_Functional_Correctness","221402970_Automated_Assume-Guarantee_Reasoning_by_Abstraction_Refinement","220997939_Dependent_Types_in_Practical_Programming","220997725_Dependent_Types_from_Counterexamples","220997299_Verifying_Higher-Order_Functional_Programs_with_Pattern-Matching_Algebraic_Data_Types","220962251_Lecture_Notes_in_Computer_Science","220852073_Learning_Assumptions_for_Compositional_Verification","220752217_Liquid_types","220245900_Automated_assume-guarantee_reasoning_for_omega-regular_systems_and_specifications","35038269_A_quantitative_approach_to_the_formal_verification_of_real-time_systems","3504397_Implicit_Enumeration_of_Finite_State_Machines_using_BDDs","2823157_Model_Checking_and_Modular_Verification","2397660_Compositional_Reasoning_in_Model_Checking","2394006_Symbolic_Model_Checking_with_Partitioned_Transition_Relations"]}